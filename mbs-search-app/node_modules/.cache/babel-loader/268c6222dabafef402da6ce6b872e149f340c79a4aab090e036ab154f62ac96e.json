{"ast":null,"code":"const AZURE_SEARCH_ENDPOINT = 'https://testopenaiservice102.search.windows.net';\nconst AZURE_SEARCH_API_KEY = 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2';\nconst AZURE_SEARCH_INDEX = 'azuresql-index-v2';\nconst buildFilterString = filters => {\n  if (!filters || Object.keys(filters).length === 0) {\n    return '';\n  }\n  const filterParts = [];\n  Object.entries(filters).forEach(([field, values]) => {\n    if (values && values.length > 0) {\n      const fieldFilters = values.map(value => {\n        // Check if the field is a string type and needs quotes\n        if (['Category', 'SubGroup', 'SubHeading', 'ScheduleId', 'ItemNum'].includes(field)) {\n          return `${field} eq ${value}`;\n        } else {\n          return `${field} eq '${value}'`;\n        }\n      });\n      if (fieldFilters.length === 1) {\n        filterParts.push(fieldFilters[0]);\n      } else {\n        filterParts.push(`(${fieldFilters.join(' or ')})`);\n      }\n    }\n  });\n  return filterParts.join(' and ');\n};\nconst getFacetableFields = () => {\n  return ['CategoryDescription', 'GroupDescription', 'ItemType', 'ItemTypeDesciption', 'ProviderType', 'FeeType', 'FeeTypeName', 'BenefitType', 'NewItem', 'ItemChange', 'FeeChange'];\n};\nexport const searchService = {\n  search: async (query, page = 1, pageSize = 10, filters = {}, sortBy = '') => {\n    const skip = (page - 1) * pageSize;\n    const filterString = buildFilterString(filters);\n    const facetString = getFacetableFields().join(',');\n\n    // Build request parameters\n    const params = new URLSearchParams({\n      'api-version': '2020-06-30',\n      'search': query,\n      'searchFields': 'Description,HumanReadableDescription,ItemNumAlias,CategoryDescription,GroupDescription',\n      'searchMode': 'all',\n      'queryType': 'simple',\n      'count': 'true',\n      'facets': facetString,\n      '$skip': skip.toString(),\n      '$top': pageSize.toString(),\n      '$select': '*'\n    });\n\n    // Add filter if present\n    if (filterString) {\n      params.append('$filter', filterString);\n    }\n\n    // Add orderby if present\n    if (sortBy) {\n      params.append('$orderby', sortBy);\n    }\n    try {\n      const response = await fetch(`${AZURE_SEARCH_ENDPOINT}/indexes/${AZURE_SEARCH_INDEX}/docs/search?${params.toString()}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': AZURE_SEARCH_API_KEY\n        },\n        body: JSON.stringify({\n          search: query,\n          searchFields: \"Description,HumanReadableDescription,ItemNumAlias,CategoryDescription,GroupDescription\",\n          searchMode: \"all\",\n          queryType: \"simple\",\n          count: true,\n          facets: facetString,\n          skip: skip,\n          top: pageSize,\n          filter: filterString || undefined,\n          orderby: sortBy || undefined\n        })\n      });\n      if (!response.ok) {\n        var _errorData$error;\n        const errorData = await response.json();\n        throw new Error(`Search API error: ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || response.statusText}`);\n      }\n      const data = await response.json();\n\n      // Process facets\n      const processedFacets = {};\n      if (data['@search.facets']) {\n        Object.entries(data['@search.facets']).forEach(([facetName, facetValues]) => {\n          processedFacets[facetName] = facetValues.map(facet => ({\n            value: facet.value,\n            count: facet.count\n          }));\n        });\n      }\n      return {\n        results: data.value || [],\n        facets: processedFacets,\n        count: data['@odata.count'] || 0\n      };\n    } catch (error) {\n      console.error('Search service error:', error);\n      throw error;\n    }\n  }\n};","map":{"version":3,"names":["AZURE_SEARCH_ENDPOINT","AZURE_SEARCH_API_KEY","AZURE_SEARCH_INDEX","buildFilterString","filters","Object","keys","length","filterParts","entries","forEach","field","values","fieldFilters","map","value","includes","push","join","getFacetableFields","searchService","search","query","page","pageSize","sortBy","skip","filterString","facetString","params","URLSearchParams","toString","append","response","fetch","method","headers","body","JSON","stringify","searchFields","searchMode","queryType","count","facets","top","filter","undefined","orderby","ok","_errorData$error","errorData","json","Error","error","message","statusText","data","processedFacets","facetName","facetValues","facet","results","console"],"sources":["C:/Projects/MBSSearchReact/mbs-search-app/src/services/searchService.js"],"sourcesContent":["const AZURE_SEARCH_ENDPOINT = 'https://testopenaiservice102.search.windows.net';\nconst AZURE_SEARCH_API_KEY = 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2';\nconst AZURE_SEARCH_INDEX = 'azuresql-index-v2';\n\nconst buildFilterString = (filters) => {\n  if (!filters || Object.keys(filters).length === 0) {\n    return '';\n  }\n  \n  const filterParts = [];\n  \n  Object.entries(filters).forEach(([field, values]) => {\n    if (values && values.length > 0) {\n      const fieldFilters = values.map(value => {\n        // Check if the field is a string type and needs quotes\n        if (['Category', 'SubGroup', 'SubHeading', 'ScheduleId', 'ItemNum'].includes(field)) {\n          return `${field} eq ${value}`;\n        } else {\n          return `${field} eq '${value}'`;\n        }\n      });\n      \n      if (fieldFilters.length === 1) {\n        filterParts.push(fieldFilters[0]);\n      } else {\n        filterParts.push(`(${fieldFilters.join(' or ')})`);\n      }\n    }\n  });\n  \n  return filterParts.join(' and ');\n};\n\nconst getFacetableFields = () => {\n  return [\n    'CategoryDescription',\n    'GroupDescription',\n    'ItemType',\n    'ItemTypeDesciption',\n    'ProviderType',\n    'FeeType',\n    'FeeTypeName',\n    'BenefitType',\n    'NewItem',\n    'ItemChange',\n    'FeeChange'\n  ];\n};\n\nexport const searchService = {\n  search: async (query, page = 1, pageSize = 10, filters = {}, sortBy = '') => {\n    const skip = (page - 1) * pageSize;\n    const filterString = buildFilterString(filters);\n    const facetString = getFacetableFields().join(',');\n    \n    // Build request parameters\n    const params = new URLSearchParams({\n      'api-version': '2020-06-30',\n      'search': query,\n      'searchFields': 'Description,HumanReadableDescription,ItemNumAlias,CategoryDescription,GroupDescription',\n      'searchMode': 'all',\n      'queryType': 'simple',\n      'count': 'true',\n      'facets': facetString,\n      '$skip': skip.toString(),\n      '$top': pageSize.toString(),\n      '$select': '*'\n    });\n    \n    // Add filter if present\n    if (filterString) {\n      params.append('$filter', filterString);\n    }\n    \n    // Add orderby if present\n    if (sortBy) {\n      params.append('$orderby', sortBy);\n    }\n    \n    try {\n      const response = await fetch(`${AZURE_SEARCH_ENDPOINT}/indexes/${AZURE_SEARCH_INDEX}/docs/search?${params.toString()}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': AZURE_SEARCH_API_KEY\n        },\n        body: JSON.stringify({\n          search: query,\n          searchFields: \"Description,HumanReadableDescription,ItemNumAlias,CategoryDescription,GroupDescription\",\n          searchMode: \"all\",\n          queryType: \"simple\",\n          count: true,\n          facets: facetString,\n          skip: skip,\n          top: pageSize,\n          filter: filterString || undefined,\n          orderby: sortBy || undefined\n        })\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(`Search API error: ${errorData.error?.message || response.statusText}`);\n      }\n      \n      const data = await response.json();\n      \n      // Process facets\n      const processedFacets = {};\n      if (data['@search.facets']) {\n        Object.entries(data['@search.facets']).forEach(([facetName, facetValues]) => {\n          processedFacets[facetName] = facetValues.map(facet => ({\n            value: facet.value,\n            count: facet.count\n          }));\n        });\n      }\n      \n      return {\n        results: data.value || [],\n        facets: processedFacets,\n        count: data['@odata.count'] || 0\n      };\n    } catch (error) {\n      console.error('Search service error:', error);\n      throw error;\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}