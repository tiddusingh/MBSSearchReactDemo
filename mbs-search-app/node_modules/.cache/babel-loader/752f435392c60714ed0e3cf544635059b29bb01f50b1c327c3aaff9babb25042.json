{"ast":null,"code":"// Azure Cognitive Search service configuration\nconst SEARCH_API_ENDPOINT = process.env.REACT_APP_AZURE_SEARCH_SERVICE || 'https://testopenaiservice102.search.windows.net';\nconst SEARCH_API_KEY = process.env.REACT_APP_AZURE_SEARCH_API_KEY || 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2';\nconst SEARCH_INDEX_NAME = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME || 'azuresql-index-v2';\nconst SEARCH_API_VERSION = '2021-04-30-Preview'; // Using preview version for semantic search\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance') => {\n  try {\n    // Build the search request\n    const searchRequest = {\n      search: query,\n      queryType: 'semantic',\n      semanticConfiguration: 'SematicConfig1',\n      searchFields: 'ItemNumAlias,Description,HumanReadableDescription,CategoryDescription,GroupDescription,Group,ItemType',\n      select: ['MBSItemId', 'ItemNum', 'ItemNumAlias', 'Description', 'HumanReadableDescription', 'Category', 'CategoryDescription', 'Group', 'GroupDescription', 'ItemType', 'ItemStartDate', 'ItemEndDate', 'ScheduleFee', 'NewItem', 'FeeType', 'SpecialistService', 'BenefitType'].join(','),\n      count: true,\n      facets: ['CategoryDescription', 'GroupDescription', 'ItemType', 'FeeType', 'NewItem'],\n      skip: (page - 1) * 10,\n      top: 10,\n      queryLanguage: 'en-us'\n    };\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            // Handle different data types appropriately\n            if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n              return `${facetName} eq '${value}'`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting if not by relevance\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'item_num_asc':\n          searchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'item_num_desc':\n          searchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'fee_asc':\n          searchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'fee_desc':\n          searchRequest.orderby = 'ScheduleFee desc';\n          break;\n        default:\n          // No sorting\n          break;\n      }\n    }\n\n    // Make the search request\n    const response = await fetch(`${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'api-key': SEARCH_API_KEY\n      },\n      body: JSON.stringify(searchRequest)\n    });\n    if (!response.ok) {\n      var _errorData$error;\n      const errorData = await response.json();\n      throw new Error(`Search API error: ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || response.statusText}`);\n    }\n    const data = await response.json();\n\n    // Process facets\n    const facets = {};\n    for (const [facetName, facetValues] of Object.entries(data['@search.facets'] || {})) {\n      facets[facetName] = facetValues.map(facet => {\n        var _selectedFacets$facet;\n        return {\n          value: facet.value,\n          count: facet.count,\n          selected: ((_selectedFacets$facet = selectedFacets[facetName]) === null || _selectedFacets$facet === void 0 ? void 0 : _selectedFacets$facet.includes(facet.value)) || false\n        };\n      });\n    }\n\n    // Format display names for facets\n    const facetDisplayNames = {\n      'CategoryDescription': 'Category',\n      'GroupDescription': 'Group',\n      'ItemType': 'Item Type',\n      'FeeType': 'Fee Type',\n      'NewItem': 'New Items'\n    };\n    const formattedFacets = {};\n    for (const [facetName, facetValues] of Object.entries(facets)) {\n      const displayName = facetDisplayNames[facetName] || facetName;\n      formattedFacets[facetName] = {\n        displayName,\n        values: facetValues\n      };\n    }\n\n    // Special handling for NewItem facet\n    if (formattedFacets.NewItem) {\n      formattedFacets.NewItem.values = formattedFacets.NewItem.values.map(item => {\n        if (item.value === 'Y') {\n          return {\n            ...item,\n            displayValue: 'Yes'\n          };\n        } else if (item.value === 'N') {\n          return {\n            ...item,\n            displayValue: 'No'\n          };\n        }\n        return {\n          ...item,\n          displayValue: item.value\n        };\n      });\n    }\n    return {\n      results: data.value,\n      facets: formattedFacets,\n      count: data['@odata.count'] || 0\n    };\n  } catch (error) {\n    console.error('Error searching MBS items:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["SEARCH_API_ENDPOINT","process","env","REACT_APP_AZURE_SEARCH_SERVICE","SEARCH_API_KEY","REACT_APP_AZURE_SEARCH_API_KEY","SEARCH_INDEX_NAME","REACT_APP_AZURE_SEARCH_INDEX_NAME","SEARCH_API_VERSION","searchItems","query","selectedFacets","page","sortBy","searchRequest","search","queryType","semanticConfiguration","searchFields","select","join","count","facets","skip","top","queryLanguage","Object","keys","length","filterExpressions","facetName","facetValues","entries","facetFilters","map","value","replace","push","filter","orderby","response","fetch","method","headers","body","JSON","stringify","ok","_errorData$error","errorData","json","Error","error","message","statusText","data","facet","_selectedFacets$facet","selected","includes","facetDisplayNames","formattedFacets","displayName","values","NewItem","item","displayValue","results","console"],"sources":["c:/Projects/MBSSearchReact/mbs-search-app/src/services/searchService.js"],"sourcesContent":["// Azure Cognitive Search service configuration\nconst SEARCH_API_ENDPOINT = process.env.REACT_APP_AZURE_SEARCH_SERVICE || 'https://testopenaiservice102.search.windows.net';\nconst SEARCH_API_KEY = process.env.REACT_APP_AZURE_SEARCH_API_KEY || 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2'; \nconst SEARCH_INDEX_NAME = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME || 'azuresql-index-v2';\nconst SEARCH_API_VERSION = '2021-04-30-Preview'; // Using preview version for semantic search\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance') => {\n  try {\n    // Build the search request\n    const searchRequest = {\n      search: query,\n      queryType: 'semantic',\n      semanticConfiguration: 'SematicConfig1',\n      searchFields: 'ItemNumAlias,Description,HumanReadableDescription,CategoryDescription,GroupDescription,Group,ItemType',\n      select: [\n        'MBSItemId', 'ItemNum', 'ItemNumAlias', 'Description', 'HumanReadableDescription',\n        'Category', 'CategoryDescription', 'Group', 'GroupDescription', 'ItemType',\n        'ItemStartDate', 'ItemEndDate', 'ScheduleFee', 'NewItem', 'FeeType',\n        'SpecialistService', 'BenefitType'\n      ].join(','),\n      count: true,\n      facets: [\n        'CategoryDescription',\n        'GroupDescription',\n        'ItemType',\n        'FeeType',\n        'NewItem'\n      ],\n      skip: (page - 1) * 10,\n      top: 10,\n      queryLanguage: 'en-us'\n    };\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      \n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            // Handle different data types appropriately\n            if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n              return `${facetName} eq '${value}'`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          \n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      \n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting if not by relevance\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'item_num_asc':\n          searchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'item_num_desc':\n          searchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'fee_asc':\n          searchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'fee_desc':\n          searchRequest.orderby = 'ScheduleFee desc';\n          break;\n        default:\n          // No sorting\n          break;\n      }\n    }\n\n    // Make the search request\n    const response = await fetch(\n      `${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': SEARCH_API_KEY\n        },\n        body: JSON.stringify(searchRequest)\n      }\n    );\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(`Search API error: ${errorData.error?.message || response.statusText}`);\n    }\n\n    const data = await response.json();\n\n    // Process facets\n    const facets = {};\n    for (const [facetName, facetValues] of Object.entries(data['@search.facets'] || {})) {\n      facets[facetName] = facetValues.map(facet => ({\n        value: facet.value,\n        count: facet.count,\n        selected: selectedFacets[facetName]?.includes(facet.value) || false\n      }));\n    }\n\n    // Format display names for facets\n    const facetDisplayNames = {\n      'CategoryDescription': 'Category',\n      'GroupDescription': 'Group',\n      'ItemType': 'Item Type',\n      'FeeType': 'Fee Type',\n      'NewItem': 'New Items'\n    };\n\n    const formattedFacets = {};\n    for (const [facetName, facetValues] of Object.entries(facets)) {\n      const displayName = facetDisplayNames[facetName] || facetName;\n      formattedFacets[facetName] = {\n        displayName,\n        values: facetValues\n      };\n    }\n\n    // Special handling for NewItem facet\n    if (formattedFacets.NewItem) {\n      formattedFacets.NewItem.values = formattedFacets.NewItem.values.map(item => {\n        if (item.value === 'Y') {\n          return { ...item, displayValue: 'Yes' };\n        } else if (item.value === 'N') {\n          return { ...item, displayValue: 'No' };\n        }\n        return { ...item, displayValue: item.value };\n      });\n    }\n\n    return {\n      results: data.value,\n      facets: formattedFacets,\n      count: data['@odata.count'] || 0\n    };\n  } catch (error) {\n    console.error('Error searching MBS items:', error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}