{"ast":null,"code":"// Azure Cognitive Search service configuration\nimport { SEARCH_CONFIG, SEARCH_SETTINGS } from '../config';\nimport { getSortParams, emitProgressEvent } from '../utils';\n\n// Get environment variables\nconst searchServiceName = process.env.REACT_APP_AZURE_SEARCH_SERVICE;\nconst searchApiKey = process.env.REACT_APP_AZURE_SEARCH_API_KEY;\nconst searchIndexName = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME;\n\n// Base URL for Azure Search API\nconst baseUrl = `https://${searchServiceName}.search.windows.net/indexes/${searchIndexName}`;\nconst apiVersion = '2021-04-30-Preview';\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type (simple or semantic)\n * @param {number} fuzzyLevel - Fuzzy search level (0-3, where 0 means no fuzzy search)\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance', queryType = 'simple', fuzzyLevel = 0) => {\n  try {\n    console.log('Searching with query:', query);\n    console.log('API Endpoint:', SEARCH_CONFIG.API_ENDPOINT);\n    console.log('Index Name:', SEARCH_CONFIG.INDEX_NAME);\n    console.log('Query Type:', queryType);\n    console.log('Fuzzy Level:', fuzzyLevel);\n\n    // Build the search request\n    const searchRequest = {\n      search: query || '*',\n      // Use '*' for empty queries to return all results\n      queryType: 'simple',\n      // Default to simple query type\n      searchFields: SEARCH_SETTINGS.SEARCH_FIELDS.join(','),\n      // Search in configured fields\n      select: SEARCH_SETTINGS.SELECT_FIELDS.join(','),\n      count: true,\n      facets: SEARCH_SETTINGS.FACET_FIELDS,\n      skip: (page - 1) * SEARCH_SETTINGS.PAGE_SIZE,\n      top: SEARCH_SETTINGS.PAGE_SIZE,\n      highlight: SEARCH_SETTINGS.HIGHLIGHT_SETTINGS.FIELDS.join(','),\n      highlightPreTag: SEARCH_SETTINGS.HIGHLIGHT_SETTINGS.PRE_TAG,\n      highlightPostTag: SEARCH_SETTINGS.HIGHLIGHT_SETTINGS.POST_TAG\n    };\n\n    // Add fuzzy search if enabled\n    if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n      searchRequest.searchMode = 'all'; // Match all terms (AND operator)\n      searchRequest.queryType = 'full'; // Use full Lucene query syntax for fuzzy search\n\n      // Reformat query for fuzzy search if it's not empty\n      if (query && query.trim() !== '') {\n        // Split the query into words and add fuzzy operator to each\n        const words = query.trim().split(/\\s+/);\n        const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n        searchRequest.search = fuzzyQuery;\n        console.log('Fuzzy query:', fuzzyQuery);\n      }\n    }\n    // Add semantic search configuration if queryType is semantic and fuzzy search is not enabled\n    else if (queryType === 'semantic') {\n      searchRequest.queryType = 'semantic';\n      searchRequest.queryLanguage = 'en-us';\n      searchRequest.semanticConfiguration = 'default';\n      searchRequest.answers = 'extractive|count-3';\n      searchRequest.captions = 'extractive|highlight-false';\n    }\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = buildFilterExpressions(selectedFacets);\n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting based on the selected option\n    searchRequest.orderby = getSortParams(sortBy, query);\n    console.log('Search request:', JSON.stringify(searchRequest, null, 2));\n\n    // Make the search request\n    const response = await fetch(`${SEARCH_CONFIG.API_ENDPOINT}/indexes/${SEARCH_CONFIG.INDEX_NAME}/docs/search?api-version=${SEARCH_CONFIG.API_VERSION}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'api-key': SEARCH_CONFIG.API_KEY\n      },\n      body: JSON.stringify(searchRequest)\n    });\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Search API error response:', errorText);\n      throw await handleApiError(response, errorText);\n    }\n    const data = await response.json();\n    console.log('Search API response:', data);\n\n    // Process facets\n    const facets = processFacets(data['@search.facets'], selectedFacets);\n\n    // Process results and add highlighted text if available\n    const processedResults = processResults(data.value);\n\n    // Process semantic answers if available\n    let semanticAnswers = processSemanticAnswers(data['@search.answers']);\n\n    // Process semantic captions if available\n    if (data['@search.captions']) {\n      processedResults.forEach((item, index) => {\n        if (data.value[index]['@search.captions']) {\n          item.caption = data.value[index]['@search.captions'].text;\n        }\n      });\n    }\n    return {\n      results: processedResults,\n      facets: facets,\n      count: data['@odata.count'] || 0,\n      semanticAnswers: semanticAnswers\n    };\n  } catch (error) {\n    console.error('Error searching items:', error);\n    throw error;\n  }\n};\n\n/**\n * Fetch all search results for export\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type (simple or semantic)\n * @param {number} fuzzyLevel - Fuzzy search level (0-3, where 0 means no fuzzy search)\n * @returns {Promise<Array>} - All search results\n */\nexport const fetchAllResultsForExport = async (query, selectedFacets = {}, sortBy = 'relevance', queryType = 'simple', fuzzyLevel = 0) => {\n  try {\n    console.log('Fetching all results for export with query:', query);\n\n    // First, get the total count of results\n    const totalCount = await getResultCount(query, selectedFacets, queryType, fuzzyLevel);\n\n    // Emit progress event\n    emitProgressEvent(10);\n\n    // If no results, return empty array\n    if (totalCount === 0) {\n      return [];\n    }\n\n    // Now fetch all results in batches\n    const batchSize = SEARCH_SETTINGS.MAX_BATCH_SIZE; // Azure Search max batch size\n    const batches = Math.ceil(totalCount / batchSize);\n    let allResults = [];\n\n    // Build the base search request\n    const baseSearchRequest = buildBaseSearchRequest(query, selectedFacets, sortBy, queryType, fuzzyLevel);\n\n    // Fetch all batches\n    for (let i = 0; i < batches; i++) {\n      const skip = i * batchSize;\n      const searchRequest = {\n        ...baseSearchRequest,\n        skip: skip\n      };\n      console.log(`Fetching batch ${i + 1}/${batches} (skip: ${skip}, top: ${batchSize})`);\n\n      // Calculate and emit progress (10-70% range for fetching)\n      const progressPercent = 10 + Math.round(i / batches * 60);\n      emitProgressEvent(progressPercent);\n      const response = await fetch(`${SEARCH_CONFIG.API_ENDPOINT}/indexes/${SEARCH_CONFIG.INDEX_NAME}/docs/search?api-version=${SEARCH_CONFIG.API_VERSION}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': SEARCH_CONFIG.API_KEY\n        },\n        body: JSON.stringify(searchRequest)\n      });\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(`Export API error response (batch ${i + 1}):`, errorText);\n        throw await handleApiError(response, errorText);\n      }\n      const data = await response.json();\n      console.log(`Batch ${i + 1} results: ${data.value.length}`);\n\n      // Add results from this batch\n      allResults = [...allResults, ...data.value];\n    }\n    console.log(`Total results fetched for export: ${allResults.length}`);\n    return allResults;\n  } catch (error) {\n    console.error('Error fetching all results for export:', error);\n    throw error;\n  }\n};\n\n/**\n * Get the total count of results for a query\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {string} queryType - Query type (simple or semantic)\n * @param {number} fuzzyLevel - Fuzzy search level\n * @returns {Promise<number>} - Total count of results\n */\nasync function getResultCount(query, selectedFacets, queryType, fuzzyLevel) {\n  const countRequest = {\n    search: query || '*',\n    queryType: 'simple',\n    // Default to simple query type\n    searchFields: SEARCH_SETTINGS.SEARCH_FIELDS.join(','),\n    select: 'MBSItemId',\n    // Just need one field for count\n    count: true,\n    skip: 0,\n    top: 1 // Just need one result to get the count\n  };\n\n  // Add fuzzy search if enabled\n  if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n    countRequest.searchMode = 'all';\n    countRequest.queryType = 'full';\n    if (query && query.trim() !== '') {\n      const words = query.trim().split(/\\s+/);\n      const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n      countRequest.search = fuzzyQuery;\n    }\n  }\n  // Add semantic search configuration if queryType is semantic and fuzzy search is not enabled\n  else if (queryType === 'semantic') {\n    countRequest.queryType = 'semantic';\n    countRequest.queryLanguage = 'en-us';\n    countRequest.semanticConfiguration = 'default';\n    countRequest.answers = 'extractive|count-3';\n    countRequest.captions = 'extractive|highlight-false';\n  }\n\n  // Add filters based on selected facets\n  if (Object.keys(selectedFacets).length > 0) {\n    const filterExpressions = buildFilterExpressions(selectedFacets);\n    if (filterExpressions.length > 0) {\n      countRequest.filter = filterExpressions.join(' and ');\n    }\n  }\n\n  // Get the count\n  const countResponse = await fetch(`${SEARCH_CONFIG.API_ENDPOINT}/indexes/${SEARCH_CONFIG.INDEX_NAME}/docs/search?api-version=${SEARCH_CONFIG.API_VERSION}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'api-key': SEARCH_CONFIG.API_KEY\n    },\n    body: JSON.stringify(countRequest)\n  });\n  if (!countResponse.ok) {\n    throw new Error(`Count API error: ${countResponse.status} ${countResponse.statusText}`);\n  }\n  const countData = await countResponse.json();\n  const totalCount = countData['@odata.count'] || 0;\n  console.log(`Total results to export: ${totalCount}`);\n  return totalCount;\n}\n\n/**\n * Build base search request for export\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type\n * @param {number} fuzzyLevel - Fuzzy search level\n * @returns {Object} - Base search request\n */\nfunction buildBaseSearchRequest(query, selectedFacets, sortBy, queryType, fuzzyLevel) {\n  const baseSearchRequest = {\n    search: query || '*',\n    queryType: 'simple',\n    // Default to simple query type\n    searchFields: SEARCH_SETTINGS.SEARCH_FIELDS.join(','),\n    select: SEARCH_SETTINGS.SELECT_FIELDS.join(','),\n    count: false,\n    top: SEARCH_SETTINGS.MAX_BATCH_SIZE\n  };\n\n  // Add fuzzy search if enabled\n  if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n    baseSearchRequest.searchMode = 'all';\n    baseSearchRequest.queryType = 'full';\n    if (query && query.trim() !== '') {\n      const words = query.trim().split(/\\s+/);\n      const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n      baseSearchRequest.search = fuzzyQuery;\n    }\n  }\n  // Add semantic search configuration if queryType is semantic and fuzzy search is not enabled\n  else if (queryType === 'semantic') {\n    baseSearchRequest.queryType = 'semantic';\n    baseSearchRequest.queryLanguage = 'en-us';\n    baseSearchRequest.semanticConfiguration = 'default';\n    baseSearchRequest.answers = 'extractive|count-3';\n    baseSearchRequest.captions = 'extractive|highlight-false';\n  }\n\n  // Add filters based on selected facets\n  if (Object.keys(selectedFacets).length > 0) {\n    const filterExpressions = buildFilterExpressions(selectedFacets);\n    if (filterExpressions.length > 0) {\n      baseSearchRequest.filter = filterExpressions.join(' and ');\n    }\n  }\n\n  // Add sorting based on the selected option\n  baseSearchRequest.orderby = getSortParams(sortBy, query);\n  return baseSearchRequest;\n}\n\n/**\n * Build filter expressions for Azure Search\n * @param {Object} selectedFacets - Selected facet filters\n * @returns {Array} - Filter expressions\n */\nfunction buildFilterExpressions(selectedFacets) {\n  const filterExpressions = [];\n  for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n    if (facetValues.length > 0) {\n      const facetFilters = facetValues.map(value => {\n        if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n          return `${facetName} eq '${value}'`;\n        } else {\n          return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n        }\n      });\n      filterExpressions.push(`(${facetFilters.join(' or ')})`);\n    }\n  }\n  return filterExpressions;\n}\n\n/**\n * Process facets from search results\n * @param {Object} searchFacets - Facets from search results\n * @param {Object} selectedFacets - Selected facet filters\n * @returns {Object} - Processed facets\n */\nfunction processFacets(searchFacets, selectedFacets) {\n  const facets = {};\n  if (searchFacets) {\n    for (const [facetName, facetValues] of Object.entries(searchFacets)) {\n      if (SEARCH_SETTINGS.FACET_FIELDS.includes(facetName)) {\n        facets[facetName] = facetValues.map(facet => {\n          var _selectedFacets$facet;\n          return {\n            value: facet.value,\n            count: facet.count,\n            selected: ((_selectedFacets$facet = selectedFacets[facetName]) === null || _selectedFacets$facet === void 0 ? void 0 : _selectedFacets$facet.includes(facet.value)) || false\n          };\n        });\n      }\n    }\n  }\n  return facets;\n}\n\n/**\n * Process search results\n * @param {Array} results - Search results\n * @returns {Array} - Processed results\n */\nfunction processResults(results) {\n  return results.map(item => {\n    // Check if this item has highlights in the response\n    if (item['@search.highlights'] && item['@search.highlights'].Description && item['@search.highlights'].Description.length > 0) {\n      return {\n        ...item,\n        highlightedDescription: item['@search.highlights'].Description[0]\n      };\n    }\n    return item;\n  });\n}\n\n/**\n * Process semantic answers from search results\n * @param {Array} answers - Semantic answers\n * @returns {Array|null} - Processed semantic answers\n */\nfunction processSemanticAnswers(answers) {\n  if (!answers) return null;\n  return answers.map(answer => ({\n    text: answer.text,\n    highlights: answer.highlights,\n    score: answer.score\n  }));\n}\n\n/**\n * Handle API error responses\n * @param {Response} response - Fetch response\n * @param {string} errorText - Error text\n * @returns {Error} - Error object\n */\nasync function handleApiError(response, errorText) {\n  try {\n    var _errorData$error;\n    const errorData = JSON.parse(errorText);\n    return new Error(`API error: ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || response.statusText}`);\n  } catch (parseError) {\n    return new Error(`API error: ${response.status} ${response.statusText}`);\n  }\n}\n\n/**\n * Get autocomplete suggestions from Azure Search\n * @param {string} query - The partial query to get suggestions for\n * @returns {Promise<Array>} - Array of suggestions\n */\nexport const getAutocompleteSuggestions = async query => {\n  if (!query || query.trim().length < 2) {\n    return [];\n  }\n  try {\n    // Use the search API instead of autocomplete since we might not have a suggester configured\n    const searchParams = {\n      search: `${query}*`,\n      // Use prefix search\n      queryType: 'full',\n      searchFields: 'Description,CategoryDescription,GroupDescription',\n      select: 'Description,CategoryDescription,GroupDescription',\n      top: 10,\n      searchMode: 'any'\n    };\n\n    // Build the URL\n    const url = `${SEARCH_CONFIG.SEARCH_ENDPOINT}/indexes/${SEARCH_CONFIG.INDEX_NAME}/docs/search?api-version=${SEARCH_CONFIG.API_VERSION}`;\n\n    // Make the request\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'api-key': SEARCH_CONFIG.API_KEY\n      },\n      body: JSON.stringify(searchParams)\n    });\n    if (!response.ok) {\n      const errorData = await response.json();\n      console.error('Autocomplete API error:', errorData);\n      throw new Error(`Autocomplete API error: ${response.status} ${response.statusText}`);\n    }\n    const data = await response.json();\n\n    // Process results to create suggestion objects\n    const suggestions = [];\n\n    // Add unique suggestions from different fields\n    const addedTexts = new Set();\n    data.value.forEach(item => {\n      // Add Description suggestions\n      if (item.Description && !addedTexts.has(item.Description)) {\n        suggestions.push({\n          text: item.Description\n        });\n        addedTexts.add(item.Description);\n      }\n\n      // Add CategoryDescription suggestions\n      if (item.CategoryDescription && !addedTexts.has(item.CategoryDescription)) {\n        suggestions.push({\n          text: item.CategoryDescription\n        });\n        addedTexts.add(item.CategoryDescription);\n      }\n\n      // Add GroupDescription suggestions\n      if (item.GroupDescription && !addedTexts.has(item.GroupDescription)) {\n        suggestions.push({\n          text: item.GroupDescription\n        });\n        addedTexts.add(item.GroupDescription);\n      }\n    });\n\n    // Limit to 10 suggestions\n    return suggestions.slice(0, 10);\n  } catch (error) {\n    console.error('Error getting autocomplete suggestions:', error);\n    return [];\n  }\n};","map":{"version":3,"names":["SEARCH_CONFIG","SEARCH_SETTINGS","getSortParams","emitProgressEvent","searchServiceName","process","env","REACT_APP_AZURE_SEARCH_SERVICE","searchApiKey","REACT_APP_AZURE_SEARCH_API_KEY","searchIndexName","REACT_APP_AZURE_SEARCH_INDEX_NAME","baseUrl","apiVersion","searchItems","query","selectedFacets","page","sortBy","queryType","fuzzyLevel","console","log","API_ENDPOINT","INDEX_NAME","searchRequest","search","searchFields","SEARCH_FIELDS","join","select","SELECT_FIELDS","count","facets","FACET_FIELDS","skip","PAGE_SIZE","top","highlight","HIGHLIGHT_SETTINGS","FIELDS","highlightPreTag","PRE_TAG","highlightPostTag","POST_TAG","searchMode","trim","words","split","fuzzyQuery","map","word","queryLanguage","semanticConfiguration","answers","captions","Object","keys","length","filterExpressions","buildFilterExpressions","filter","orderby","JSON","stringify","response","fetch","API_VERSION","method","headers","API_KEY","body","ok","errorText","text","error","handleApiError","data","json","processFacets","processedResults","processResults","value","semanticAnswers","processSemanticAnswers","forEach","item","index","caption","results","fetchAllResultsForExport","totalCount","getResultCount","batchSize","MAX_BATCH_SIZE","batches","Math","ceil","allResults","baseSearchRequest","buildBaseSearchRequest","i","progressPercent","round","countRequest","countResponse","Error","status","statusText","countData","facetName","facetValues","entries","facetFilters","replace","push","searchFacets","includes","facet","_selectedFacets$facet","selected","Description","highlightedDescription","answer","highlights","score","_errorData$error","errorData","parse","message","parseError","getAutocompleteSuggestions","searchParams","url","SEARCH_ENDPOINT","suggestions","addedTexts","Set","has","add","CategoryDescription","GroupDescription","slice"],"sources":["C:/Projects/MBSSearchReact/mbs-search-app/src/services/searchService.js"],"sourcesContent":["// Azure Cognitive Search service configuration\nimport { SEARCH_CONFIG, SEARCH_SETTINGS } from '../config';\nimport { getSortParams, emitProgressEvent } from '../utils';\n\n// Get environment variables\nconst searchServiceName = process.env.REACT_APP_AZURE_SEARCH_SERVICE;\nconst searchApiKey = process.env.REACT_APP_AZURE_SEARCH_API_KEY;\nconst searchIndexName = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME;\n\n// Base URL for Azure Search API\nconst baseUrl = `https://${searchServiceName}.search.windows.net/indexes/${searchIndexName}`;\nconst apiVersion = '2021-04-30-Preview';\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type (simple or semantic)\n * @param {number} fuzzyLevel - Fuzzy search level (0-3, where 0 means no fuzzy search)\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance', queryType = 'simple', fuzzyLevel = 0) => {\n  try {\n    console.log('Searching with query:', query);\n    console.log('API Endpoint:', SEARCH_CONFIG.API_ENDPOINT);\n    console.log('Index Name:', SEARCH_CONFIG.INDEX_NAME);\n    console.log('Query Type:', queryType);\n    console.log('Fuzzy Level:', fuzzyLevel);\n    \n    // Build the search request\n    const searchRequest = {\n      search: query || '*', // Use '*' for empty queries to return all results\n      queryType: 'simple', // Default to simple query type\n      searchFields: SEARCH_SETTINGS.SEARCH_FIELDS.join(','), // Search in configured fields\n      select: SEARCH_SETTINGS.SELECT_FIELDS.join(','),\n      count: true,\n      facets: SEARCH_SETTINGS.FACET_FIELDS,\n      skip: (page - 1) * SEARCH_SETTINGS.PAGE_SIZE,\n      top: SEARCH_SETTINGS.PAGE_SIZE,\n      highlight: SEARCH_SETTINGS.HIGHLIGHT_SETTINGS.FIELDS.join(','),\n      highlightPreTag: SEARCH_SETTINGS.HIGHLIGHT_SETTINGS.PRE_TAG,\n      highlightPostTag: SEARCH_SETTINGS.HIGHLIGHT_SETTINGS.POST_TAG\n    };\n\n    // Add fuzzy search if enabled\n    if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n      searchRequest.searchMode = 'all'; // Match all terms (AND operator)\n      searchRequest.queryType = 'full'; // Use full Lucene query syntax for fuzzy search\n      \n      // Reformat query for fuzzy search if it's not empty\n      if (query && query.trim() !== '') {\n        // Split the query into words and add fuzzy operator to each\n        const words = query.trim().split(/\\s+/);\n        const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n        searchRequest.search = fuzzyQuery;\n        console.log('Fuzzy query:', fuzzyQuery);\n      }\n    } \n    // Add semantic search configuration if queryType is semantic and fuzzy search is not enabled\n    else if (queryType === 'semantic') {\n      searchRequest.queryType = 'semantic';\n      searchRequest.queryLanguage = 'en-us';\n      searchRequest.semanticConfiguration = 'default';\n      searchRequest.answers = 'extractive|count-3';\n      searchRequest.captions = 'extractive|highlight-false';\n    }\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = buildFilterExpressions(selectedFacets);\n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting based on the selected option\n    searchRequest.orderby = getSortParams(sortBy, query);\n\n    console.log('Search request:', JSON.stringify(searchRequest, null, 2));\n\n    // Make the search request\n    const response = await fetch(\n      `${SEARCH_CONFIG.API_ENDPOINT}/indexes/${SEARCH_CONFIG.INDEX_NAME}/docs/search?api-version=${SEARCH_CONFIG.API_VERSION}`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': SEARCH_CONFIG.API_KEY\n        },\n        body: JSON.stringify(searchRequest)\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Search API error response:', errorText);\n      throw await handleApiError(response, errorText);\n    }\n\n    const data = await response.json();\n    console.log('Search API response:', data);\n\n    // Process facets\n    const facets = processFacets(data['@search.facets'], selectedFacets);\n\n    // Process results and add highlighted text if available\n    const processedResults = processResults(data.value);\n\n    // Process semantic answers if available\n    let semanticAnswers = processSemanticAnswers(data['@search.answers']);\n\n    // Process semantic captions if available\n    if (data['@search.captions']) {\n      processedResults.forEach((item, index) => {\n        if (data.value[index]['@search.captions']) {\n          item.caption = data.value[index]['@search.captions'].text;\n        }\n      });\n    }\n\n    return {\n      results: processedResults,\n      facets: facets,\n      count: data['@odata.count'] || 0,\n      semanticAnswers: semanticAnswers\n    };\n  } catch (error) {\n    console.error('Error searching items:', error);\n    throw error;\n  }\n};\n\n/**\n * Fetch all search results for export\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type (simple or semantic)\n * @param {number} fuzzyLevel - Fuzzy search level (0-3, where 0 means no fuzzy search)\n * @returns {Promise<Array>} - All search results\n */\nexport const fetchAllResultsForExport = async (query, selectedFacets = {}, sortBy = 'relevance', queryType = 'simple', fuzzyLevel = 0) => {\n  try {\n    console.log('Fetching all results for export with query:', query);\n    \n    // First, get the total count of results\n    const totalCount = await getResultCount(query, selectedFacets, queryType, fuzzyLevel);\n    \n    // Emit progress event\n    emitProgressEvent(10);\n    \n    // If no results, return empty array\n    if (totalCount === 0) {\n      return [];\n    }\n    \n    // Now fetch all results in batches\n    const batchSize = SEARCH_SETTINGS.MAX_BATCH_SIZE; // Azure Search max batch size\n    const batches = Math.ceil(totalCount / batchSize);\n    let allResults = [];\n    \n    // Build the base search request\n    const baseSearchRequest = buildBaseSearchRequest(query, selectedFacets, sortBy, queryType, fuzzyLevel);\n    \n    // Fetch all batches\n    for (let i = 0; i < batches; i++) {\n      const skip = i * batchSize;\n      const searchRequest = {\n        ...baseSearchRequest,\n        skip: skip\n      };\n      \n      console.log(`Fetching batch ${i+1}/${batches} (skip: ${skip}, top: ${batchSize})`);\n      \n      // Calculate and emit progress (10-70% range for fetching)\n      const progressPercent = 10 + Math.round((i / batches) * 60);\n      emitProgressEvent(progressPercent);\n      \n      const response = await fetch(\n        `${SEARCH_CONFIG.API_ENDPOINT}/indexes/${SEARCH_CONFIG.INDEX_NAME}/docs/search?api-version=${SEARCH_CONFIG.API_VERSION}`,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'api-key': SEARCH_CONFIG.API_KEY\n          },\n          body: JSON.stringify(searchRequest)\n        }\n      );\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(`Export API error response (batch ${i+1}):`, errorText);\n        throw await handleApiError(response, errorText);\n      }\n      \n      const data = await response.json();\n      console.log(`Batch ${i+1} results: ${data.value.length}`);\n      \n      // Add results from this batch\n      allResults = [...allResults, ...data.value];\n    }\n    \n    console.log(`Total results fetched for export: ${allResults.length}`);\n    return allResults;\n  } catch (error) {\n    console.error('Error fetching all results for export:', error);\n    throw error;\n  }\n};\n\n/**\n * Get the total count of results for a query\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {string} queryType - Query type (simple or semantic)\n * @param {number} fuzzyLevel - Fuzzy search level\n * @returns {Promise<number>} - Total count of results\n */\nasync function getResultCount(query, selectedFacets, queryType, fuzzyLevel) {\n  const countRequest = {\n    search: query || '*',\n    queryType: 'simple', // Default to simple query type\n    searchFields: SEARCH_SETTINGS.SEARCH_FIELDS.join(','),\n    select: 'MBSItemId', // Just need one field for count\n    count: true,\n    skip: 0,\n    top: 1, // Just need one result to get the count\n  };\n  \n  // Add fuzzy search if enabled\n  if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n    countRequest.searchMode = 'all';\n    countRequest.queryType = 'full';\n    \n    if (query && query.trim() !== '') {\n      const words = query.trim().split(/\\s+/);\n      const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n      countRequest.search = fuzzyQuery;\n    }\n  }\n  // Add semantic search configuration if queryType is semantic and fuzzy search is not enabled\n  else if (queryType === 'semantic') {\n    countRequest.queryType = 'semantic';\n    countRequest.queryLanguage = 'en-us';\n    countRequest.semanticConfiguration = 'default';\n    countRequest.answers = 'extractive|count-3';\n    countRequest.captions = 'extractive|highlight-false';\n  }\n  \n  // Add filters based on selected facets\n  if (Object.keys(selectedFacets).length > 0) {\n    const filterExpressions = buildFilterExpressions(selectedFacets);\n    if (filterExpressions.length > 0) {\n      countRequest.filter = filterExpressions.join(' and ');\n    }\n  }\n  \n  // Get the count\n  const countResponse = await fetch(\n    `${SEARCH_CONFIG.API_ENDPOINT}/indexes/${SEARCH_CONFIG.INDEX_NAME}/docs/search?api-version=${SEARCH_CONFIG.API_VERSION}`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'api-key': SEARCH_CONFIG.API_KEY\n      },\n      body: JSON.stringify(countRequest)\n    }\n  );\n  \n  if (!countResponse.ok) {\n    throw new Error(`Count API error: ${countResponse.status} ${countResponse.statusText}`);\n  }\n  \n  const countData = await countResponse.json();\n  const totalCount = countData['@odata.count'] || 0;\n  console.log(`Total results to export: ${totalCount}`);\n  \n  return totalCount;\n}\n\n/**\n * Build base search request for export\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type\n * @param {number} fuzzyLevel - Fuzzy search level\n * @returns {Object} - Base search request\n */\nfunction buildBaseSearchRequest(query, selectedFacets, sortBy, queryType, fuzzyLevel) {\n  const baseSearchRequest = {\n    search: query || '*',\n    queryType: 'simple', // Default to simple query type\n    searchFields: SEARCH_SETTINGS.SEARCH_FIELDS.join(','),\n    select: SEARCH_SETTINGS.SELECT_FIELDS.join(','),\n    count: false,\n    top: SEARCH_SETTINGS.MAX_BATCH_SIZE,\n  };\n  \n  // Add fuzzy search if enabled\n  if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n    baseSearchRequest.searchMode = 'all';\n    baseSearchRequest.queryType = 'full';\n    \n    if (query && query.trim() !== '') {\n      const words = query.trim().split(/\\s+/);\n      const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n      baseSearchRequest.search = fuzzyQuery;\n    }\n  }\n  // Add semantic search configuration if queryType is semantic and fuzzy search is not enabled\n  else if (queryType === 'semantic') {\n    baseSearchRequest.queryType = 'semantic';\n    baseSearchRequest.queryLanguage = 'en-us';\n    baseSearchRequest.semanticConfiguration = 'default';\n    baseSearchRequest.answers = 'extractive|count-3';\n    baseSearchRequest.captions = 'extractive|highlight-false';\n  }\n  \n  // Add filters based on selected facets\n  if (Object.keys(selectedFacets).length > 0) {\n    const filterExpressions = buildFilterExpressions(selectedFacets);\n    if (filterExpressions.length > 0) {\n      baseSearchRequest.filter = filterExpressions.join(' and ');\n    }\n  }\n  \n  // Add sorting based on the selected option\n  baseSearchRequest.orderby = getSortParams(sortBy, query);\n  \n  return baseSearchRequest;\n}\n\n/**\n * Build filter expressions for Azure Search\n * @param {Object} selectedFacets - Selected facet filters\n * @returns {Array} - Filter expressions\n */\nfunction buildFilterExpressions(selectedFacets) {\n  const filterExpressions = [];\n  \n  for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n    if (facetValues.length > 0) {\n      const facetFilters = facetValues.map(value => {\n        if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n          return `${facetName} eq '${value}'`;\n        } else {\n          return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n        }\n      });\n      \n      filterExpressions.push(`(${facetFilters.join(' or ')})`);\n    }\n  }\n  \n  return filterExpressions;\n}\n\n/**\n * Process facets from search results\n * @param {Object} searchFacets - Facets from search results\n * @param {Object} selectedFacets - Selected facet filters\n * @returns {Object} - Processed facets\n */\nfunction processFacets(searchFacets, selectedFacets) {\n  const facets = {};\n  if (searchFacets) {\n    for (const [facetName, facetValues] of Object.entries(searchFacets)) {\n      if (SEARCH_SETTINGS.FACET_FIELDS.includes(facetName)) {\n        facets[facetName] = facetValues.map(facet => ({\n          value: facet.value,\n          count: facet.count,\n          selected: selectedFacets[facetName]?.includes(facet.value) || false\n        }));\n      }\n    }\n  }\n  return facets;\n}\n\n/**\n * Process search results\n * @param {Array} results - Search results\n * @returns {Array} - Processed results\n */\nfunction processResults(results) {\n  return results.map(item => {\n    // Check if this item has highlights in the response\n    if (item['@search.highlights'] && \n        item['@search.highlights'].Description && \n        item['@search.highlights'].Description.length > 0) {\n      return {\n        ...item,\n        highlightedDescription: item['@search.highlights'].Description[0]\n      };\n    }\n    return item;\n  });\n}\n\n/**\n * Process semantic answers from search results\n * @param {Array} answers - Semantic answers\n * @returns {Array|null} - Processed semantic answers\n */\nfunction processSemanticAnswers(answers) {\n  if (!answers) return null;\n  \n  return answers.map(answer => ({\n    text: answer.text,\n    highlights: answer.highlights,\n    score: answer.score\n  }));\n}\n\n/**\n * Handle API error responses\n * @param {Response} response - Fetch response\n * @param {string} errorText - Error text\n * @returns {Error} - Error object\n */\nasync function handleApiError(response, errorText) {\n  try {\n    const errorData = JSON.parse(errorText);\n    return new Error(`API error: ${errorData.error?.message || response.statusText}`);\n  } catch (parseError) {\n    return new Error(`API error: ${response.status} ${response.statusText}`);\n  }\n}\n\n/**\n * Get autocomplete suggestions from Azure Search\n * @param {string} query - The partial query to get suggestions for\n * @returns {Promise<Array>} - Array of suggestions\n */\nexport const getAutocompleteSuggestions = async (query) => {\n  if (!query || query.trim().length < 2) {\n    return [];\n  }\n\n  try {\n    // Use the search API instead of autocomplete since we might not have a suggester configured\n    const searchParams = {\n      search: `${query}*`,  // Use prefix search\n      queryType: 'full',\n      searchFields: 'Description,CategoryDescription,GroupDescription',\n      select: 'Description,CategoryDescription,GroupDescription',\n      top: 10,\n      searchMode: 'any'\n    };\n\n    // Build the URL\n    const url = `${SEARCH_CONFIG.SEARCH_ENDPOINT}/indexes/${SEARCH_CONFIG.INDEX_NAME}/docs/search?api-version=${SEARCH_CONFIG.API_VERSION}`;\n\n    // Make the request\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'api-key': SEARCH_CONFIG.API_KEY\n      },\n      body: JSON.stringify(searchParams)\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      console.error('Autocomplete API error:', errorData);\n      throw new Error(`Autocomplete API error: ${response.status} ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    \n    // Process results to create suggestion objects\n    const suggestions = [];\n    \n    // Add unique suggestions from different fields\n    const addedTexts = new Set();\n    \n    data.value.forEach(item => {\n      // Add Description suggestions\n      if (item.Description && !addedTexts.has(item.Description)) {\n        suggestions.push({ text: item.Description });\n        addedTexts.add(item.Description);\n      }\n      \n      // Add CategoryDescription suggestions\n      if (item.CategoryDescription && !addedTexts.has(item.CategoryDescription)) {\n        suggestions.push({ text: item.CategoryDescription });\n        addedTexts.add(item.CategoryDescription);\n      }\n      \n      // Add GroupDescription suggestions\n      if (item.GroupDescription && !addedTexts.has(item.GroupDescription)) {\n        suggestions.push({ text: item.GroupDescription });\n        addedTexts.add(item.GroupDescription);\n      }\n    });\n    \n    // Limit to 10 suggestions\n    return suggestions.slice(0, 10);\n  } catch (error) {\n    console.error('Error getting autocomplete suggestions:', error);\n    return [];\n  }\n};\n"],"mappings":"AAAA;AACA,SAASA,aAAa,EAAEC,eAAe,QAAQ,WAAW;AAC1D,SAASC,aAAa,EAAEC,iBAAiB,QAAQ,UAAU;;AAE3D;AACA,MAAMC,iBAAiB,GAAGC,OAAO,CAACC,GAAG,CAACC,8BAA8B;AACpE,MAAMC,YAAY,GAAGH,OAAO,CAACC,GAAG,CAACG,8BAA8B;AAC/D,MAAMC,eAAe,GAAGL,OAAO,CAACC,GAAG,CAACK,iCAAiC;;AAErE;AACA,MAAMC,OAAO,GAAG,WAAWR,iBAAiB,+BAA+BM,eAAe,EAAE;AAC5F,MAAMG,UAAU,GAAG,oBAAoB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAG,MAAAA,CAAOC,KAAK,EAAEC,cAAc,GAAG,CAAC,CAAC,EAAEC,IAAI,GAAG,CAAC,EAAEC,MAAM,GAAG,WAAW,EAAEC,SAAS,GAAG,QAAQ,EAAEC,UAAU,GAAG,CAAC,KAAK;EACrI,IAAI;IACFC,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEP,KAAK,CAAC;IAC3CM,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEtB,aAAa,CAACuB,YAAY,CAAC;IACxDF,OAAO,CAACC,GAAG,CAAC,aAAa,EAAEtB,aAAa,CAACwB,UAAU,CAAC;IACpDH,OAAO,CAACC,GAAG,CAAC,aAAa,EAAEH,SAAS,CAAC;IACrCE,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEF,UAAU,CAAC;;IAEvC;IACA,MAAMK,aAAa,GAAG;MACpBC,MAAM,EAAEX,KAAK,IAAI,GAAG;MAAE;MACtBI,SAAS,EAAE,QAAQ;MAAE;MACrBQ,YAAY,EAAE1B,eAAe,CAAC2B,aAAa,CAACC,IAAI,CAAC,GAAG,CAAC;MAAE;MACvDC,MAAM,EAAE7B,eAAe,CAAC8B,aAAa,CAACF,IAAI,CAAC,GAAG,CAAC;MAC/CG,KAAK,EAAE,IAAI;MACXC,MAAM,EAAEhC,eAAe,CAACiC,YAAY;MACpCC,IAAI,EAAE,CAAClB,IAAI,GAAG,CAAC,IAAIhB,eAAe,CAACmC,SAAS;MAC5CC,GAAG,EAAEpC,eAAe,CAACmC,SAAS;MAC9BE,SAAS,EAAErC,eAAe,CAACsC,kBAAkB,CAACC,MAAM,CAACX,IAAI,CAAC,GAAG,CAAC;MAC9DY,eAAe,EAAExC,eAAe,CAACsC,kBAAkB,CAACG,OAAO;MAC3DC,gBAAgB,EAAE1C,eAAe,CAACsC,kBAAkB,CAACK;IACvD,CAAC;;IAED;IACA,IAAIxB,UAAU,GAAG,CAAC,IAAIA,UAAU,IAAI,CAAC,EAAE;MACrCK,aAAa,CAACoB,UAAU,GAAG,KAAK,CAAC,CAAC;MAClCpB,aAAa,CAACN,SAAS,GAAG,MAAM,CAAC,CAAC;;MAElC;MACA,IAAIJ,KAAK,IAAIA,KAAK,CAAC+B,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;QAChC;QACA,MAAMC,KAAK,GAAGhC,KAAK,CAAC+B,IAAI,CAAC,CAAC,CAACE,KAAK,CAAC,KAAK,CAAC;QACvC,MAAMC,UAAU,GAAGF,KAAK,CAACG,GAAG,CAACC,IAAI,IAAI,GAAGA,IAAI,IAAI/B,UAAU,EAAE,CAAC,CAACS,IAAI,CAAC,GAAG,CAAC;QACvEJ,aAAa,CAACC,MAAM,GAAGuB,UAAU;QACjC5B,OAAO,CAACC,GAAG,CAAC,cAAc,EAAE2B,UAAU,CAAC;MACzC;IACF;IACA;IAAA,KACK,IAAI9B,SAAS,KAAK,UAAU,EAAE;MACjCM,aAAa,CAACN,SAAS,GAAG,UAAU;MACpCM,aAAa,CAAC2B,aAAa,GAAG,OAAO;MACrC3B,aAAa,CAAC4B,qBAAqB,GAAG,SAAS;MAC/C5B,aAAa,CAAC6B,OAAO,GAAG,oBAAoB;MAC5C7B,aAAa,CAAC8B,QAAQ,GAAG,4BAA4B;IACvD;;IAEA;IACA,IAAIC,MAAM,CAACC,IAAI,CAACzC,cAAc,CAAC,CAAC0C,MAAM,GAAG,CAAC,EAAE;MAC1C,MAAMC,iBAAiB,GAAGC,sBAAsB,CAAC5C,cAAc,CAAC;MAChE,IAAI2C,iBAAiB,CAACD,MAAM,GAAG,CAAC,EAAE;QAChCjC,aAAa,CAACoC,MAAM,GAAGF,iBAAiB,CAAC9B,IAAI,CAAC,OAAO,CAAC;MACxD;IACF;;IAEA;IACAJ,aAAa,CAACqC,OAAO,GAAG5D,aAAa,CAACgB,MAAM,EAAEH,KAAK,CAAC;IAEpDM,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEyC,IAAI,CAACC,SAAS,CAACvC,aAAa,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;;IAEtE;IACA,MAAMwC,QAAQ,GAAG,MAAMC,KAAK,CAC1B,GAAGlE,aAAa,CAACuB,YAAY,YAAYvB,aAAa,CAACwB,UAAU,4BAA4BxB,aAAa,CAACmE,WAAW,EAAE,EACxH;MACEC,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACP,cAAc,EAAE,kBAAkB;QAClC,SAAS,EAAErE,aAAa,CAACsE;MAC3B,CAAC;MACDC,IAAI,EAAER,IAAI,CAACC,SAAS,CAACvC,aAAa;IACpC,CACF,CAAC;IAED,IAAI,CAACwC,QAAQ,CAACO,EAAE,EAAE;MAChB,MAAMC,SAAS,GAAG,MAAMR,QAAQ,CAACS,IAAI,CAAC,CAAC;MACvCrD,OAAO,CAACsD,KAAK,CAAC,4BAA4B,EAAEF,SAAS,CAAC;MACtD,MAAM,MAAMG,cAAc,CAACX,QAAQ,EAAEQ,SAAS,CAAC;IACjD;IAEA,MAAMI,IAAI,GAAG,MAAMZ,QAAQ,CAACa,IAAI,CAAC,CAAC;IAClCzD,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAEuD,IAAI,CAAC;;IAEzC;IACA,MAAM5C,MAAM,GAAG8C,aAAa,CAACF,IAAI,CAAC,gBAAgB,CAAC,EAAE7D,cAAc,CAAC;;IAEpE;IACA,MAAMgE,gBAAgB,GAAGC,cAAc,CAACJ,IAAI,CAACK,KAAK,CAAC;;IAEnD;IACA,IAAIC,eAAe,GAAGC,sBAAsB,CAACP,IAAI,CAAC,iBAAiB,CAAC,CAAC;;IAErE;IACA,IAAIA,IAAI,CAAC,kBAAkB,CAAC,EAAE;MAC5BG,gBAAgB,CAACK,OAAO,CAAC,CAACC,IAAI,EAAEC,KAAK,KAAK;QACxC,IAAIV,IAAI,CAACK,KAAK,CAACK,KAAK,CAAC,CAAC,kBAAkB,CAAC,EAAE;UACzCD,IAAI,CAACE,OAAO,GAAGX,IAAI,CAACK,KAAK,CAACK,KAAK,CAAC,CAAC,kBAAkB,CAAC,CAACb,IAAI;QAC3D;MACF,CAAC,CAAC;IACJ;IAEA,OAAO;MACLe,OAAO,EAAET,gBAAgB;MACzB/C,MAAM,EAAEA,MAAM;MACdD,KAAK,EAAE6C,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC;MAChCM,eAAe,EAAEA;IACnB,CAAC;EACH,CAAC,CAAC,OAAOR,KAAK,EAAE;IACdtD,OAAO,CAACsD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;IAC9C,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMe,wBAAwB,GAAG,MAAAA,CAAO3E,KAAK,EAAEC,cAAc,GAAG,CAAC,CAAC,EAAEE,MAAM,GAAG,WAAW,EAAEC,SAAS,GAAG,QAAQ,EAAEC,UAAU,GAAG,CAAC,KAAK;EACxI,IAAI;IACFC,OAAO,CAACC,GAAG,CAAC,6CAA6C,EAAEP,KAAK,CAAC;;IAEjE;IACA,MAAM4E,UAAU,GAAG,MAAMC,cAAc,CAAC7E,KAAK,EAAEC,cAAc,EAAEG,SAAS,EAAEC,UAAU,CAAC;;IAErF;IACAjB,iBAAiB,CAAC,EAAE,CAAC;;IAErB;IACA,IAAIwF,UAAU,KAAK,CAAC,EAAE;MACpB,OAAO,EAAE;IACX;;IAEA;IACA,MAAME,SAAS,GAAG5F,eAAe,CAAC6F,cAAc,CAAC,CAAC;IAClD,MAAMC,OAAO,GAAGC,IAAI,CAACC,IAAI,CAACN,UAAU,GAAGE,SAAS,CAAC;IACjD,IAAIK,UAAU,GAAG,EAAE;;IAEnB;IACA,MAAMC,iBAAiB,GAAGC,sBAAsB,CAACrF,KAAK,EAAEC,cAAc,EAAEE,MAAM,EAAEC,SAAS,EAAEC,UAAU,CAAC;;IAEtG;IACA,KAAK,IAAIiF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,OAAO,EAAEM,CAAC,EAAE,EAAE;MAChC,MAAMlE,IAAI,GAAGkE,CAAC,GAAGR,SAAS;MAC1B,MAAMpE,aAAa,GAAG;QACpB,GAAG0E,iBAAiB;QACpBhE,IAAI,EAAEA;MACR,CAAC;MAEDd,OAAO,CAACC,GAAG,CAAC,kBAAkB+E,CAAC,GAAC,CAAC,IAAIN,OAAO,WAAW5D,IAAI,UAAU0D,SAAS,GAAG,CAAC;;MAElF;MACA,MAAMS,eAAe,GAAG,EAAE,GAAGN,IAAI,CAACO,KAAK,CAAEF,CAAC,GAAGN,OAAO,GAAI,EAAE,CAAC;MAC3D5F,iBAAiB,CAACmG,eAAe,CAAC;MAElC,MAAMrC,QAAQ,GAAG,MAAMC,KAAK,CAC1B,GAAGlE,aAAa,CAACuB,YAAY,YAAYvB,aAAa,CAACwB,UAAU,4BAA4BxB,aAAa,CAACmE,WAAW,EAAE,EACxH;QACEC,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,SAAS,EAAErE,aAAa,CAACsE;QAC3B,CAAC;QACDC,IAAI,EAAER,IAAI,CAACC,SAAS,CAACvC,aAAa;MACpC,CACF,CAAC;MAED,IAAI,CAACwC,QAAQ,CAACO,EAAE,EAAE;QAChB,MAAMC,SAAS,GAAG,MAAMR,QAAQ,CAACS,IAAI,CAAC,CAAC;QACvCrD,OAAO,CAACsD,KAAK,CAAC,oCAAoC0B,CAAC,GAAC,CAAC,IAAI,EAAE5B,SAAS,CAAC;QACrE,MAAM,MAAMG,cAAc,CAACX,QAAQ,EAAEQ,SAAS,CAAC;MACjD;MAEA,MAAMI,IAAI,GAAG,MAAMZ,QAAQ,CAACa,IAAI,CAAC,CAAC;MAClCzD,OAAO,CAACC,GAAG,CAAC,SAAS+E,CAAC,GAAC,CAAC,aAAaxB,IAAI,CAACK,KAAK,CAACxB,MAAM,EAAE,CAAC;;MAEzD;MACAwC,UAAU,GAAG,CAAC,GAAGA,UAAU,EAAE,GAAGrB,IAAI,CAACK,KAAK,CAAC;IAC7C;IAEA7D,OAAO,CAACC,GAAG,CAAC,qCAAqC4E,UAAU,CAACxC,MAAM,EAAE,CAAC;IACrE,OAAOwC,UAAU;EACnB,CAAC,CAAC,OAAOvB,KAAK,EAAE;IACdtD,OAAO,CAACsD,KAAK,CAAC,wCAAwC,EAAEA,KAAK,CAAC;IAC9D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeiB,cAAcA,CAAC7E,KAAK,EAAEC,cAAc,EAAEG,SAAS,EAAEC,UAAU,EAAE;EAC1E,MAAMoF,YAAY,GAAG;IACnB9E,MAAM,EAAEX,KAAK,IAAI,GAAG;IACpBI,SAAS,EAAE,QAAQ;IAAE;IACrBQ,YAAY,EAAE1B,eAAe,CAAC2B,aAAa,CAACC,IAAI,CAAC,GAAG,CAAC;IACrDC,MAAM,EAAE,WAAW;IAAE;IACrBE,KAAK,EAAE,IAAI;IACXG,IAAI,EAAE,CAAC;IACPE,GAAG,EAAE,CAAC,CAAE;EACV,CAAC;;EAED;EACA,IAAIjB,UAAU,GAAG,CAAC,IAAIA,UAAU,IAAI,CAAC,EAAE;IACrCoF,YAAY,CAAC3D,UAAU,GAAG,KAAK;IAC/B2D,YAAY,CAACrF,SAAS,GAAG,MAAM;IAE/B,IAAIJ,KAAK,IAAIA,KAAK,CAAC+B,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;MAChC,MAAMC,KAAK,GAAGhC,KAAK,CAAC+B,IAAI,CAAC,CAAC,CAACE,KAAK,CAAC,KAAK,CAAC;MACvC,MAAMC,UAAU,GAAGF,KAAK,CAACG,GAAG,CAACC,IAAI,IAAI,GAAGA,IAAI,IAAI/B,UAAU,EAAE,CAAC,CAACS,IAAI,CAAC,GAAG,CAAC;MACvE2E,YAAY,CAAC9E,MAAM,GAAGuB,UAAU;IAClC;EACF;EACA;EAAA,KACK,IAAI9B,SAAS,KAAK,UAAU,EAAE;IACjCqF,YAAY,CAACrF,SAAS,GAAG,UAAU;IACnCqF,YAAY,CAACpD,aAAa,GAAG,OAAO;IACpCoD,YAAY,CAACnD,qBAAqB,GAAG,SAAS;IAC9CmD,YAAY,CAAClD,OAAO,GAAG,oBAAoB;IAC3CkD,YAAY,CAACjD,QAAQ,GAAG,4BAA4B;EACtD;;EAEA;EACA,IAAIC,MAAM,CAACC,IAAI,CAACzC,cAAc,CAAC,CAAC0C,MAAM,GAAG,CAAC,EAAE;IAC1C,MAAMC,iBAAiB,GAAGC,sBAAsB,CAAC5C,cAAc,CAAC;IAChE,IAAI2C,iBAAiB,CAACD,MAAM,GAAG,CAAC,EAAE;MAChC8C,YAAY,CAAC3C,MAAM,GAAGF,iBAAiB,CAAC9B,IAAI,CAAC,OAAO,CAAC;IACvD;EACF;;EAEA;EACA,MAAM4E,aAAa,GAAG,MAAMvC,KAAK,CAC/B,GAAGlE,aAAa,CAACuB,YAAY,YAAYvB,aAAa,CAACwB,UAAU,4BAA4BxB,aAAa,CAACmE,WAAW,EAAE,EACxH;IACEC,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MACP,cAAc,EAAE,kBAAkB;MAClC,SAAS,EAAErE,aAAa,CAACsE;IAC3B,CAAC;IACDC,IAAI,EAAER,IAAI,CAACC,SAAS,CAACwC,YAAY;EACnC,CACF,CAAC;EAED,IAAI,CAACC,aAAa,CAACjC,EAAE,EAAE;IACrB,MAAM,IAAIkC,KAAK,CAAC,oBAAoBD,aAAa,CAACE,MAAM,IAAIF,aAAa,CAACG,UAAU,EAAE,CAAC;EACzF;EAEA,MAAMC,SAAS,GAAG,MAAMJ,aAAa,CAAC3B,IAAI,CAAC,CAAC;EAC5C,MAAMa,UAAU,GAAGkB,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC;EACjDxF,OAAO,CAACC,GAAG,CAAC,4BAA4BqE,UAAU,EAAE,CAAC;EAErD,OAAOA,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,sBAAsBA,CAACrF,KAAK,EAAEC,cAAc,EAAEE,MAAM,EAAEC,SAAS,EAAEC,UAAU,EAAE;EACpF,MAAM+E,iBAAiB,GAAG;IACxBzE,MAAM,EAAEX,KAAK,IAAI,GAAG;IACpBI,SAAS,EAAE,QAAQ;IAAE;IACrBQ,YAAY,EAAE1B,eAAe,CAAC2B,aAAa,CAACC,IAAI,CAAC,GAAG,CAAC;IACrDC,MAAM,EAAE7B,eAAe,CAAC8B,aAAa,CAACF,IAAI,CAAC,GAAG,CAAC;IAC/CG,KAAK,EAAE,KAAK;IACZK,GAAG,EAAEpC,eAAe,CAAC6F;EACvB,CAAC;;EAED;EACA,IAAI1E,UAAU,GAAG,CAAC,IAAIA,UAAU,IAAI,CAAC,EAAE;IACrC+E,iBAAiB,CAACtD,UAAU,GAAG,KAAK;IACpCsD,iBAAiB,CAAChF,SAAS,GAAG,MAAM;IAEpC,IAAIJ,KAAK,IAAIA,KAAK,CAAC+B,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;MAChC,MAAMC,KAAK,GAAGhC,KAAK,CAAC+B,IAAI,CAAC,CAAC,CAACE,KAAK,CAAC,KAAK,CAAC;MACvC,MAAMC,UAAU,GAAGF,KAAK,CAACG,GAAG,CAACC,IAAI,IAAI,GAAGA,IAAI,IAAI/B,UAAU,EAAE,CAAC,CAACS,IAAI,CAAC,GAAG,CAAC;MACvEsE,iBAAiB,CAACzE,MAAM,GAAGuB,UAAU;IACvC;EACF;EACA;EAAA,KACK,IAAI9B,SAAS,KAAK,UAAU,EAAE;IACjCgF,iBAAiB,CAAChF,SAAS,GAAG,UAAU;IACxCgF,iBAAiB,CAAC/C,aAAa,GAAG,OAAO;IACzC+C,iBAAiB,CAAC9C,qBAAqB,GAAG,SAAS;IACnD8C,iBAAiB,CAAC7C,OAAO,GAAG,oBAAoB;IAChD6C,iBAAiB,CAAC5C,QAAQ,GAAG,4BAA4B;EAC3D;;EAEA;EACA,IAAIC,MAAM,CAACC,IAAI,CAACzC,cAAc,CAAC,CAAC0C,MAAM,GAAG,CAAC,EAAE;IAC1C,MAAMC,iBAAiB,GAAGC,sBAAsB,CAAC5C,cAAc,CAAC;IAChE,IAAI2C,iBAAiB,CAACD,MAAM,GAAG,CAAC,EAAE;MAChCyC,iBAAiB,CAACtC,MAAM,GAAGF,iBAAiB,CAAC9B,IAAI,CAAC,OAAO,CAAC;IAC5D;EACF;;EAEA;EACAsE,iBAAiB,CAACrC,OAAO,GAAG5D,aAAa,CAACgB,MAAM,EAAEH,KAAK,CAAC;EAExD,OAAOoF,iBAAiB;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASvC,sBAAsBA,CAAC5C,cAAc,EAAE;EAC9C,MAAM2C,iBAAiB,GAAG,EAAE;EAE5B,KAAK,MAAM,CAACmD,SAAS,EAAEC,WAAW,CAAC,IAAIvD,MAAM,CAACwD,OAAO,CAAChG,cAAc,CAAC,EAAE;IACrE,IAAI+F,WAAW,CAACrD,MAAM,GAAG,CAAC,EAAE;MAC1B,MAAMuD,YAAY,GAAGF,WAAW,CAAC7D,GAAG,CAACgC,KAAK,IAAI;QAC5C,IAAI4B,SAAS,KAAK,SAAS,IAAIA,SAAS,KAAK,WAAW,IAAIA,SAAS,KAAK,YAAY,EAAE;UACtF,OAAO,GAAGA,SAAS,QAAQ5B,KAAK,GAAG;QACrC,CAAC,MAAM;UACL,OAAO,GAAG4B,SAAS,QAAQ5B,KAAK,CAACgC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG;QACzD;MACF,CAAC,CAAC;MAEFvD,iBAAiB,CAACwD,IAAI,CAAC,IAAIF,YAAY,CAACpF,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;IAC1D;EACF;EAEA,OAAO8B,iBAAiB;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoB,aAAaA,CAACqC,YAAY,EAAEpG,cAAc,EAAE;EACnD,MAAMiB,MAAM,GAAG,CAAC,CAAC;EACjB,IAAImF,YAAY,EAAE;IAChB,KAAK,MAAM,CAACN,SAAS,EAAEC,WAAW,CAAC,IAAIvD,MAAM,CAACwD,OAAO,CAACI,YAAY,CAAC,EAAE;MACnE,IAAInH,eAAe,CAACiC,YAAY,CAACmF,QAAQ,CAACP,SAAS,CAAC,EAAE;QACpD7E,MAAM,CAAC6E,SAAS,CAAC,GAAGC,WAAW,CAAC7D,GAAG,CAACoE,KAAK;UAAA,IAAAC,qBAAA;UAAA,OAAK;YAC5CrC,KAAK,EAAEoC,KAAK,CAACpC,KAAK;YAClBlD,KAAK,EAAEsF,KAAK,CAACtF,KAAK;YAClBwF,QAAQ,EAAE,EAAAD,qBAAA,GAAAvG,cAAc,CAAC8F,SAAS,CAAC,cAAAS,qBAAA,uBAAzBA,qBAAA,CAA2BF,QAAQ,CAACC,KAAK,CAACpC,KAAK,CAAC,KAAI;UAChE,CAAC;QAAA,CAAC,CAAC;MACL;IACF;EACF;EACA,OAAOjD,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASgD,cAAcA,CAACQ,OAAO,EAAE;EAC/B,OAAOA,OAAO,CAACvC,GAAG,CAACoC,IAAI,IAAI;IACzB;IACA,IAAIA,IAAI,CAAC,oBAAoB,CAAC,IAC1BA,IAAI,CAAC,oBAAoB,CAAC,CAACmC,WAAW,IACtCnC,IAAI,CAAC,oBAAoB,CAAC,CAACmC,WAAW,CAAC/D,MAAM,GAAG,CAAC,EAAE;MACrD,OAAO;QACL,GAAG4B,IAAI;QACPoC,sBAAsB,EAAEpC,IAAI,CAAC,oBAAoB,CAAC,CAACmC,WAAW,CAAC,CAAC;MAClE,CAAC;IACH;IACA,OAAOnC,IAAI;EACb,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASF,sBAAsBA,CAAC9B,OAAO,EAAE;EACvC,IAAI,CAACA,OAAO,EAAE,OAAO,IAAI;EAEzB,OAAOA,OAAO,CAACJ,GAAG,CAACyE,MAAM,KAAK;IAC5BjD,IAAI,EAAEiD,MAAM,CAACjD,IAAI;IACjBkD,UAAU,EAAED,MAAM,CAACC,UAAU;IAC7BC,KAAK,EAAEF,MAAM,CAACE;EAChB,CAAC,CAAC,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAejD,cAAcA,CAACX,QAAQ,EAAEQ,SAAS,EAAE;EACjD,IAAI;IAAA,IAAAqD,gBAAA;IACF,MAAMC,SAAS,GAAGhE,IAAI,CAACiE,KAAK,CAACvD,SAAS,CAAC;IACvC,OAAO,IAAIiC,KAAK,CAAC,cAAc,EAAAoB,gBAAA,GAAAC,SAAS,CAACpD,KAAK,cAAAmD,gBAAA,uBAAfA,gBAAA,CAAiBG,OAAO,KAAIhE,QAAQ,CAAC2C,UAAU,EAAE,CAAC;EACnF,CAAC,CAAC,OAAOsB,UAAU,EAAE;IACnB,OAAO,IAAIxB,KAAK,CAAC,cAAczC,QAAQ,CAAC0C,MAAM,IAAI1C,QAAQ,CAAC2C,UAAU,EAAE,CAAC;EAC1E;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMuB,0BAA0B,GAAG,MAAOpH,KAAK,IAAK;EACzD,IAAI,CAACA,KAAK,IAAIA,KAAK,CAAC+B,IAAI,CAAC,CAAC,CAACY,MAAM,GAAG,CAAC,EAAE;IACrC,OAAO,EAAE;EACX;EAEA,IAAI;IACF;IACA,MAAM0E,YAAY,GAAG;MACnB1G,MAAM,EAAE,GAAGX,KAAK,GAAG;MAAG;MACtBI,SAAS,EAAE,MAAM;MACjBQ,YAAY,EAAE,kDAAkD;MAChEG,MAAM,EAAE,kDAAkD;MAC1DO,GAAG,EAAE,EAAE;MACPQ,UAAU,EAAE;IACd,CAAC;;IAED;IACA,MAAMwF,GAAG,GAAG,GAAGrI,aAAa,CAACsI,eAAe,YAAYtI,aAAa,CAACwB,UAAU,4BAA4BxB,aAAa,CAACmE,WAAW,EAAE;;IAEvI;IACA,MAAMF,QAAQ,GAAG,MAAMC,KAAK,CAACmE,GAAG,EAAE;MAChCjE,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACP,cAAc,EAAE,kBAAkB;QAClC,SAAS,EAAErE,aAAa,CAACsE;MAC3B,CAAC;MACDC,IAAI,EAAER,IAAI,CAACC,SAAS,CAACoE,YAAY;IACnC,CAAC,CAAC;IAEF,IAAI,CAACnE,QAAQ,CAACO,EAAE,EAAE;MAChB,MAAMuD,SAAS,GAAG,MAAM9D,QAAQ,CAACa,IAAI,CAAC,CAAC;MACvCzD,OAAO,CAACsD,KAAK,CAAC,yBAAyB,EAAEoD,SAAS,CAAC;MACnD,MAAM,IAAIrB,KAAK,CAAC,2BAA2BzC,QAAQ,CAAC0C,MAAM,IAAI1C,QAAQ,CAAC2C,UAAU,EAAE,CAAC;IACtF;IAEA,MAAM/B,IAAI,GAAG,MAAMZ,QAAQ,CAACa,IAAI,CAAC,CAAC;;IAElC;IACA,MAAMyD,WAAW,GAAG,EAAE;;IAEtB;IACA,MAAMC,UAAU,GAAG,IAAIC,GAAG,CAAC,CAAC;IAE5B5D,IAAI,CAACK,KAAK,CAACG,OAAO,CAACC,IAAI,IAAI;MACzB;MACA,IAAIA,IAAI,CAACmC,WAAW,IAAI,CAACe,UAAU,CAACE,GAAG,CAACpD,IAAI,CAACmC,WAAW,CAAC,EAAE;QACzDc,WAAW,CAACpB,IAAI,CAAC;UAAEzC,IAAI,EAAEY,IAAI,CAACmC;QAAY,CAAC,CAAC;QAC5Ce,UAAU,CAACG,GAAG,CAACrD,IAAI,CAACmC,WAAW,CAAC;MAClC;;MAEA;MACA,IAAInC,IAAI,CAACsD,mBAAmB,IAAI,CAACJ,UAAU,CAACE,GAAG,CAACpD,IAAI,CAACsD,mBAAmB,CAAC,EAAE;QACzEL,WAAW,CAACpB,IAAI,CAAC;UAAEzC,IAAI,EAAEY,IAAI,CAACsD;QAAoB,CAAC,CAAC;QACpDJ,UAAU,CAACG,GAAG,CAACrD,IAAI,CAACsD,mBAAmB,CAAC;MAC1C;;MAEA;MACA,IAAItD,IAAI,CAACuD,gBAAgB,IAAI,CAACL,UAAU,CAACE,GAAG,CAACpD,IAAI,CAACuD,gBAAgB,CAAC,EAAE;QACnEN,WAAW,CAACpB,IAAI,CAAC;UAAEzC,IAAI,EAAEY,IAAI,CAACuD;QAAiB,CAAC,CAAC;QACjDL,UAAU,CAACG,GAAG,CAACrD,IAAI,CAACuD,gBAAgB,CAAC;MACvC;IACF,CAAC,CAAC;;IAEF;IACA,OAAON,WAAW,CAACO,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACjC,CAAC,CAAC,OAAOnE,KAAK,EAAE;IACdtD,OAAO,CAACsD,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;IAC/D,OAAO,EAAE;EACX;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}