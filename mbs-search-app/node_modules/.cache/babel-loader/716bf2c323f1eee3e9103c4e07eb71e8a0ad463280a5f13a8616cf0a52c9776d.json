{"ast":null,"code":"// Azure Cognitive Search service configuration\nconst SEARCH_API_ENDPOINT = process.env.REACT_APP_AZURE_SEARCH_SERVICE || 'https://testopenaiservice102.search.windows.net';\nconst SEARCH_API_KEY = process.env.REACT_APP_AZURE_SEARCH_API_KEY || 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2';\nconst SEARCH_INDEX_NAME = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME || 'azuresql-index-v2';\nconst SEARCH_API_VERSION = '2021-04-30-Preview'; // Using preview version for semantic search\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type (simple, semantic, or fuzzy)\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance', queryType = 'hybrid') => {\n  try {\n    console.log('Searching with query:', query);\n    console.log('API Endpoint:', SEARCH_API_ENDPOINT);\n    console.log('Index Name:', SEARCH_INDEX_NAME);\n    console.log('Query Type:', queryType);\n\n    // Build the search request\n    const searchRequest = {\n      search: query || '*',\n      // Use '*' for empty queries to return all results\n      queryType: queryType === 'semantic' ? 'semantic' : 'simple',\n      // Use semantic or simple query type\n      searchFields: 'Description',\n      // Search in Description field\n      select: ['MBSItemId', 'ItemNum', 'ItemNumAlias', 'Description', 'HumanReadableDescription', 'Category', 'CategoryDescription', 'Group', 'GroupDescription', 'ItemType', 'ItemStartDate', 'ItemEndDate', 'ScheduleFee', 'NewItem', 'FeeType'].join(','),\n      count: true,\n      facets: ['CategoryDescription', 'GroupDescription'],\n      skip: (page - 1) * 10,\n      top: 10,\n      highlight: 'Description',\n      // Add highlighting for Description field\n      highlightPreTag: '<mark>',\n      // HTML tag to wrap highlighted terms (start)\n      highlightPostTag: '</mark>' // HTML tag to wrap highlighted terms (end)\n    };\n\n    // Apply fuzzy search by default for non-empty queries in hybrid mode\n    // This helps handle spelling mistakes like \"medcal\" instead of \"medical\"\n    if ((queryType === 'hybrid' || queryType === 'fuzzy') && query && query.trim() !== '') {\n      // Apply fuzzy search to each term in the query\n      const terms = query.trim().split(/\\s+/);\n      const fuzzyTerms = terms.map(term => `${term}~1`); // Edit distance of 1\n      searchRequest.search = fuzzyTerms.join(' ');\n\n      // Add speller to suggest corrections\n      searchRequest.speller = 'lexicon';\n    }\n\n    // Add semantic search configuration if queryType is semantic\n    if (queryType === 'semantic') {\n      searchRequest.queryLanguage = 'en-us';\n      searchRequest.semanticConfiguration = 'default';\n      searchRequest.queryAnswer = 'extractive|count-3';\n      searchRequest.captions = 'extractive|highlight-false';\n    }\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            // Handle different data types appropriately\n            if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n              return `${facetName} eq '${value}'`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting based on the selected option\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'item_num_asc':\n          searchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'item_num_desc':\n          searchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'fee_asc':\n          searchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'fee_desc':\n          searchRequest.orderby = 'ScheduleFee desc';\n          break;\n        default:\n          // Default to relevance sorting\n          break;\n      }\n    } else if (query && query.trim() !== '') {\n      // For non-empty queries, sort by search score by default\n      searchRequest.orderby = 'search.score() desc';\n    } else {\n      // For empty queries, sort by ItemNum by default\n      searchRequest.orderby = 'ItemNum asc';\n    }\n    console.log('Search request:', JSON.stringify(searchRequest, null, 2));\n\n    // Make the search request\n    const response = await fetch(`${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'api-key': SEARCH_API_KEY\n      },\n      body: JSON.stringify(searchRequest)\n    });\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Search API error response:', errorText);\n      try {\n        var _errorData$error;\n        const errorData = JSON.parse(errorText);\n        throw new Error(`Search API error: ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || response.statusText}`);\n      } catch (parseError) {\n        throw new Error(`Search API error: ${response.status} ${response.statusText}`);\n      }\n    }\n    const data = await response.json();\n    console.log('Search API response:', data);\n\n    // Process facets\n    const facets = {};\n    if (data['@search.facets']) {\n      for (const [facetName, facetValues] of Object.entries(data['@search.facets'])) {\n        if (facetName === 'CategoryDescription' || facetName === 'GroupDescription') {\n          facets[facetName] = facetValues.map(facet => {\n            var _selectedFacets$facet;\n            return {\n              value: facet.value,\n              count: facet.count,\n              selected: ((_selectedFacets$facet = selectedFacets[facetName]) === null || _selectedFacets$facet === void 0 ? void 0 : _selectedFacets$facet.includes(facet.value)) || false\n            };\n          });\n        }\n      }\n    }\n\n    // Process results and add highlighted text if available\n    const processedResults = data.value.map(item => {\n      // Check if this item has highlights in the response\n      if (item['@search.highlights'] && item['@search.highlights'].Description && item['@search.highlights'].Description.length > 0) {\n        return {\n          ...item,\n          highlightedDescription: item['@search.highlights'].Description[0]\n        };\n      }\n      return item;\n    });\n\n    // Process semantic answers if available\n    let semanticAnswers = null;\n    if (data['@search.answers']) {\n      semanticAnswers = data['@search.answers'].map(answer => ({\n        text: answer.text,\n        highlights: answer.highlights,\n        score: answer.score\n      }));\n      console.log('Semantic answers:', semanticAnswers);\n    }\n\n    // Process semantic captions if available\n    if (data['@search.captions']) {\n      processedResults.forEach((item, index) => {\n        if (data['@search.captions'][index]) {\n          item.semanticCaption = data['@search.captions'][index].text;\n        }\n      });\n    }\n\n    // Process spelling suggestions if available\n    let spellingSuggestions = null;\n    if (data['@search.spellingSuggestions']) {\n      spellingSuggestions = data['@search.spellingSuggestions'];\n      console.log('Spelling suggestions:', spellingSuggestions);\n    }\n    return {\n      results: processedResults || [],\n      facets: facets,\n      count: data['@odata.count'] || 0,\n      semanticAnswers: semanticAnswers,\n      spellingSuggestions: spellingSuggestions\n    };\n  } catch (error) {\n    console.error('Error searching MBS items:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["SEARCH_API_ENDPOINT","process","env","REACT_APP_AZURE_SEARCH_SERVICE","SEARCH_API_KEY","REACT_APP_AZURE_SEARCH_API_KEY","SEARCH_INDEX_NAME","REACT_APP_AZURE_SEARCH_INDEX_NAME","SEARCH_API_VERSION","searchItems","query","selectedFacets","page","sortBy","queryType","console","log","searchRequest","search","searchFields","select","join","count","facets","skip","top","highlight","highlightPreTag","highlightPostTag","trim","terms","split","fuzzyTerms","map","term","speller","queryLanguage","semanticConfiguration","queryAnswer","captions","Object","keys","length","filterExpressions","facetName","facetValues","entries","facetFilters","value","replace","push","filter","orderby","JSON","stringify","response","fetch","method","headers","body","ok","errorText","text","error","_errorData$error","errorData","parse","Error","message","statusText","parseError","status","data","json","facet","_selectedFacets$facet","selected","includes","processedResults","item","Description","highlightedDescription","semanticAnswers","answer","highlights","score","forEach","index","semanticCaption","spellingSuggestions","results"],"sources":["C:/Projects/MBSSearchReact/mbs-search-app/src/services/searchService.js"],"sourcesContent":["// Azure Cognitive Search service configuration\nconst SEARCH_API_ENDPOINT = process.env.REACT_APP_AZURE_SEARCH_SERVICE || 'https://testopenaiservice102.search.windows.net';\nconst SEARCH_API_KEY = process.env.REACT_APP_AZURE_SEARCH_API_KEY || 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2'; \nconst SEARCH_INDEX_NAME = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME || 'azuresql-index-v2';\nconst SEARCH_API_VERSION = '2021-04-30-Preview'; // Using preview version for semantic search\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type (simple, semantic, or fuzzy)\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance', queryType = 'hybrid') => {\n  try {\n    console.log('Searching with query:', query);\n    console.log('API Endpoint:', SEARCH_API_ENDPOINT);\n    console.log('Index Name:', SEARCH_INDEX_NAME);\n    console.log('Query Type:', queryType);\n    \n    // Build the search request\n    const searchRequest = {\n      search: query || '*', // Use '*' for empty queries to return all results\n      queryType: queryType === 'semantic' ? 'semantic' : 'simple', // Use semantic or simple query type\n      searchFields: 'Description', // Search in Description field\n      select: [\n        'MBSItemId', 'ItemNum', 'ItemNumAlias', 'Description', 'HumanReadableDescription',\n        'Category', 'CategoryDescription', 'Group', 'GroupDescription', 'ItemType',\n        'ItemStartDate', 'ItemEndDate', 'ScheduleFee', 'NewItem', 'FeeType'\n      ].join(','),\n      count: true,\n      facets: [\n        'CategoryDescription',\n        'GroupDescription'\n      ],\n      skip: (page - 1) * 10,\n      top: 10,\n      highlight: 'Description', // Add highlighting for Description field\n      highlightPreTag: '<mark>', // HTML tag to wrap highlighted terms (start)\n      highlightPostTag: '</mark>' // HTML tag to wrap highlighted terms (end)\n    };\n\n    // Apply fuzzy search by default for non-empty queries in hybrid mode\n    // This helps handle spelling mistakes like \"medcal\" instead of \"medical\"\n    if ((queryType === 'hybrid' || queryType === 'fuzzy') && query && query.trim() !== '') {\n      // Apply fuzzy search to each term in the query\n      const terms = query.trim().split(/\\s+/);\n      const fuzzyTerms = terms.map(term => `${term}~1`); // Edit distance of 1\n      searchRequest.search = fuzzyTerms.join(' ');\n      \n      // Add speller to suggest corrections\n      searchRequest.speller = 'lexicon';\n    }\n\n    // Add semantic search configuration if queryType is semantic\n    if (queryType === 'semantic') {\n      searchRequest.queryLanguage = 'en-us';\n      searchRequest.semanticConfiguration = 'default';\n      searchRequest.queryAnswer = 'extractive|count-3';\n      searchRequest.captions = 'extractive|highlight-false';\n    }\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      \n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            // Handle different data types appropriately\n            if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n              return `${facetName} eq '${value}'`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          \n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      \n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting based on the selected option\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'item_num_asc':\n          searchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'item_num_desc':\n          searchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'fee_asc':\n          searchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'fee_desc':\n          searchRequest.orderby = 'ScheduleFee desc';\n          break;\n        default:\n          // Default to relevance sorting\n          break;\n      }\n    } else if (query && query.trim() !== '') {\n      // For non-empty queries, sort by search score by default\n      searchRequest.orderby = 'search.score() desc';\n    } else {\n      // For empty queries, sort by ItemNum by default\n      searchRequest.orderby = 'ItemNum asc';\n    }\n\n    console.log('Search request:', JSON.stringify(searchRequest, null, 2));\n\n    // Make the search request\n    const response = await fetch(\n      `${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': SEARCH_API_KEY\n        },\n        body: JSON.stringify(searchRequest)\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Search API error response:', errorText);\n      try {\n        const errorData = JSON.parse(errorText);\n        throw new Error(`Search API error: ${errorData.error?.message || response.statusText}`);\n      } catch (parseError) {\n        throw new Error(`Search API error: ${response.status} ${response.statusText}`);\n      }\n    }\n\n    const data = await response.json();\n    console.log('Search API response:', data);\n\n    // Process facets\n    const facets = {};\n    if (data['@search.facets']) {\n      for (const [facetName, facetValues] of Object.entries(data['@search.facets'])) {\n        if (facetName === 'CategoryDescription' || facetName === 'GroupDescription') {\n          facets[facetName] = facetValues.map(facet => ({\n            value: facet.value,\n            count: facet.count,\n            selected: selectedFacets[facetName]?.includes(facet.value) || false\n          }));\n        }\n      }\n    }\n\n    // Process results and add highlighted text if available\n    const processedResults = data.value.map(item => {\n      // Check if this item has highlights in the response\n      if (item['@search.highlights'] && item['@search.highlights'].Description && item['@search.highlights'].Description.length > 0) {\n        return {\n          ...item,\n          highlightedDescription: item['@search.highlights'].Description[0]\n        };\n      }\n      return item;\n    });\n\n    // Process semantic answers if available\n    let semanticAnswers = null;\n    if (data['@search.answers']) {\n      semanticAnswers = data['@search.answers'].map(answer => ({\n        text: answer.text,\n        highlights: answer.highlights,\n        score: answer.score\n      }));\n      console.log('Semantic answers:', semanticAnswers);\n    }\n\n    // Process semantic captions if available\n    if (data['@search.captions']) {\n      processedResults.forEach((item, index) => {\n        if (data['@search.captions'][index]) {\n          item.semanticCaption = data['@search.captions'][index].text;\n        }\n      });\n    }\n    \n    // Process spelling suggestions if available\n    let spellingSuggestions = null;\n    if (data['@search.spellingSuggestions']) {\n      spellingSuggestions = data['@search.spellingSuggestions'];\n      console.log('Spelling suggestions:', spellingSuggestions);\n    }\n\n    return {\n      results: processedResults || [],\n      facets: facets,\n      count: data['@odata.count'] || 0,\n      semanticAnswers: semanticAnswers,\n      spellingSuggestions: spellingSuggestions\n    };\n  } catch (error) {\n    console.error('Error searching MBS items:', error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}