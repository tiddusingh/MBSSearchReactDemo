{"ast":null,"code":"// Azure Cognitive Search service configuration\nconst SEARCH_API_ENDPOINT = process.env.REACT_APP_AZURE_SEARCH_SERVICE || 'https://testopenaiservice102.search.windows.net';\nconst SEARCH_API_KEY = process.env.REACT_APP_AZURE_SEARCH_API_KEY || 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2';\nconst SEARCH_INDEX_NAME = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME || 'azuresql-index-v2';\nconst SEARCH_API_VERSION = '2021-04-30-Preview'; // Using preview version for semantic search\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance') => {\n  try {\n    console.log('Searching with query:', query);\n    console.log('API Endpoint:', SEARCH_API_ENDPOINT);\n    console.log('Index Name:', SEARCH_INDEX_NAME);\n\n    // Build the search request - simplifying to match the working ApiTest approach\n    const searchRequest = {\n      search: query || '*',\n      // Use '*' for empty queries to return all results\n      queryType: 'simple',\n      // Using simple query type for compatibility\n      searchFields: 'Description',\n      // Search in Description field\n      select: 'MBSItemId,ItemNum,ItemNumAlias,Description,HumanReadableDescription,Category,CategoryDescription,Group,GroupDescription,ItemType,ItemStartDate,ItemEndDate,ScheduleFee,NewItem,FeeType',\n      count: true,\n      skip: (page - 1) * 10,\n      top: 10\n    };\n\n    // Add facets if supported by the index\n    searchRequest.facets = ['CategoryDescription', 'GroupDescription', 'NewItem', 'ItemStartDate'];\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            // Handle different data types appropriately\n            if (facetName === 'NewItem') {\n              return `${facetName} eq '${value}'`;\n            } else if (facetName === 'ItemStartDate') {\n              // For dates, use the edm.DateTimeOffset format\n              return `${facetName} eq ${value}`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting if not by relevance\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'item_num_asc':\n          searchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'item_num_desc':\n          searchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'fee_asc':\n          searchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'fee_desc':\n          searchRequest.orderby = 'ScheduleFee desc';\n          break;\n        default:\n          // No sorting\n          break;\n      }\n    } else if (!query || query.trim() === '') {\n      // For empty queries, sort by ItemNum by default\n      searchRequest.orderby = 'ItemNum asc';\n    }\n    console.log('Search request:', JSON.stringify(searchRequest, null, 2));\n\n    // Make the search request\n    const response = await fetch(`${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'api-key': SEARCH_API_KEY,\n        'Accept': 'application/json'\n      },\n      body: JSON.stringify(searchRequest)\n    });\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Search API error response:', errorText);\n      try {\n        var _errorData$error;\n        const errorData = JSON.parse(errorText);\n        throw new Error(`Search API error: ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || response.statusText}`);\n      } catch (parseError) {\n        throw new Error(`Search API error: ${response.status} ${response.statusText}`);\n      }\n    }\n    const data = await response.json();\n    console.log('Search API response:', data);\n\n    // Process facets\n    const facets = {};\n    if (data['@search.facets']) {\n      for (const [facetName, facetValues] of Object.entries(data['@search.facets'])) {\n        facets[facetName] = facetValues.map(facet => {\n          var _selectedFacets$facet;\n          return {\n            value: facet.value,\n            count: facet.count,\n            selected: ((_selectedFacets$facet = selectedFacets[facetName]) === null || _selectedFacets$facet === void 0 ? void 0 : _selectedFacets$facet.includes(facet.value)) || false\n          };\n        });\n      }\n    }\n    return {\n      results: data.value || [],\n      facets: facets,\n      count: data['@odata.count'] || 0\n    };\n  } catch (error) {\n    console.error('Error searching MBS items:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["SEARCH_API_ENDPOINT","process","env","REACT_APP_AZURE_SEARCH_SERVICE","SEARCH_API_KEY","REACT_APP_AZURE_SEARCH_API_KEY","SEARCH_INDEX_NAME","REACT_APP_AZURE_SEARCH_INDEX_NAME","SEARCH_API_VERSION","searchItems","query","selectedFacets","page","sortBy","console","log","searchRequest","search","queryType","searchFields","select","count","skip","top","facets","Object","keys","length","filterExpressions","facetName","facetValues","entries","facetFilters","map","value","replace","push","join","filter","orderby","trim","JSON","stringify","response","fetch","method","headers","body","ok","errorText","text","error","_errorData$error","errorData","parse","Error","message","statusText","parseError","status","data","json","facet","_selectedFacets$facet","selected","includes","results"],"sources":["C:/Projects/MBSSearchReact/mbs-search-app/src/services/searchService.js"],"sourcesContent":["// Azure Cognitive Search service configuration\nconst SEARCH_API_ENDPOINT = process.env.REACT_APP_AZURE_SEARCH_SERVICE || 'https://testopenaiservice102.search.windows.net';\nconst SEARCH_API_KEY = process.env.REACT_APP_AZURE_SEARCH_API_KEY || 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2'; \nconst SEARCH_INDEX_NAME = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME || 'azuresql-index-v2';\nconst SEARCH_API_VERSION = '2021-04-30-Preview'; // Using preview version for semantic search\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance') => {\n  try {\n    console.log('Searching with query:', query);\n    console.log('API Endpoint:', SEARCH_API_ENDPOINT);\n    console.log('Index Name:', SEARCH_INDEX_NAME);\n    \n    // Build the search request - simplifying to match the working ApiTest approach\n    const searchRequest = {\n      search: query || '*', // Use '*' for empty queries to return all results\n      queryType: 'simple', // Using simple query type for compatibility\n      searchFields: 'Description', // Search in Description field\n      select: 'MBSItemId,ItemNum,ItemNumAlias,Description,HumanReadableDescription,Category,CategoryDescription,Group,GroupDescription,ItemType,ItemStartDate,ItemEndDate,ScheduleFee,NewItem,FeeType',\n      count: true,\n      skip: (page - 1) * 10,\n      top: 10\n    };\n\n    // Add facets if supported by the index\n    searchRequest.facets = [\n      'CategoryDescription',\n      'GroupDescription',\n      'NewItem',\n      'ItemStartDate'\n    ];\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      \n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            // Handle different data types appropriately\n            if (facetName === 'NewItem') {\n              return `${facetName} eq '${value}'`;\n            } else if (facetName === 'ItemStartDate') {\n              // For dates, use the edm.DateTimeOffset format\n              return `${facetName} eq ${value}`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          \n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      \n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting if not by relevance\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'item_num_asc':\n          searchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'item_num_desc':\n          searchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'fee_asc':\n          searchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'fee_desc':\n          searchRequest.orderby = 'ScheduleFee desc';\n          break;\n        default:\n          // No sorting\n          break;\n      }\n    } else if (!query || query.trim() === '') {\n      // For empty queries, sort by ItemNum by default\n      searchRequest.orderby = 'ItemNum asc';\n    }\n\n    console.log('Search request:', JSON.stringify(searchRequest, null, 2));\n\n    // Make the search request\n    const response = await fetch(\n      `${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': SEARCH_API_KEY,\n          'Accept': 'application/json'\n        },\n        body: JSON.stringify(searchRequest)\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Search API error response:', errorText);\n      try {\n        const errorData = JSON.parse(errorText);\n        throw new Error(`Search API error: ${errorData.error?.message || response.statusText}`);\n      } catch (parseError) {\n        throw new Error(`Search API error: ${response.status} ${response.statusText}`);\n      }\n    }\n\n    const data = await response.json();\n    console.log('Search API response:', data);\n\n    // Process facets\n    const facets = {};\n    if (data['@search.facets']) {\n      for (const [facetName, facetValues] of Object.entries(data['@search.facets'])) {\n        facets[facetName] = facetValues.map(facet => ({\n          value: facet.value,\n          count: facet.count,\n          selected: selectedFacets[facetName]?.includes(facet.value) || false\n        }));\n      }\n    }\n\n    return {\n      results: data.value || [],\n      facets: facets,\n      count: data['@odata.count'] || 0\n    };\n  } catch (error) {\n    console.error('Error searching MBS items:', error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}