{"ast":null,"code":"// Azure Cognitive Search service configuration\nconst SEARCH_API_ENDPOINT = process.env.REACT_APP_AZURE_SEARCH_SERVICE || 'https://testopenaiservice102.search.windows.net';\nconst SEARCH_API_KEY = process.env.REACT_APP_AZURE_SEARCH_API_KEY || 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2';\nconst SEARCH_INDEX_NAME = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME || 'azuresql-index-v2';\nconst SEARCH_API_VERSION = '2021-04-30-Preview'; // Using preview version for semantic search\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type (simple or semantic)\n * @param {number} fuzzyLevel - Fuzzy search level (0-3, where 0 means no fuzzy search)\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance', queryType = 'simple', fuzzyLevel = 0) => {\n  try {\n    console.log('Searching with query:', query);\n    console.log('API Endpoint:', SEARCH_API_ENDPOINT);\n    console.log('Index Name:', SEARCH_INDEX_NAME);\n    console.log('Query Type:', queryType);\n    console.log('Fuzzy Level:', fuzzyLevel);\n\n    // Build the search request\n    const searchRequest = {\n      search: query || '*',\n      // Use '*' for empty queries to return all results\n      queryType: queryType === 'semantic' ? 'semantic' : 'simple',\n      // Use semantic or simple query type\n      searchFields: 'Description',\n      // Search in Description field\n      select: ['MBSItemId', 'ItemNum', 'ItemNumAlias', 'Description', 'HumanReadableDescription', 'Category', 'CategoryDescription', 'Group', 'GroupDescription', 'ItemType', 'ItemStartDate', 'ItemEndDate', 'ScheduleFee', 'NewItem', 'FeeType'].join(','),\n      count: true,\n      facets: ['CategoryDescription', 'GroupDescription'],\n      skip: (page - 1) * 10,\n      top: 10,\n      highlight: 'Description',\n      // Add highlighting for Description field\n      highlightPreTag: '<mark>',\n      // HTML tag to wrap highlighted terms (start)\n      highlightPostTag: '</mark>' // HTML tag to wrap highlighted terms (end)\n    };\n\n    // Add fuzzy search if enabled\n    if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n      searchRequest.searchMode = 'all'; // Match all terms (AND operator)\n      searchRequest.queryType = 'full'; // Use full Lucene query syntax for fuzzy search\n\n      // Reformat query for fuzzy search if it's not empty\n      if (query && query.trim() !== '') {\n        // Split the query into words and add fuzzy operator to each\n        const words = query.trim().split(/\\s+/);\n        const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n        searchRequest.search = fuzzyQuery;\n        console.log('Fuzzy query:', fuzzyQuery);\n      }\n    }\n\n    // Add semantic search configuration if queryType is semantic\n    if (queryType === 'semantic') {\n      searchRequest.queryLanguage = 'en-us';\n      searchRequest.semanticConfiguration = 'default';\n      searchRequest.queryAnswer = 'extractive|count-3';\n      searchRequest.captions = 'extractive|highlight-false';\n    }\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            // Handle different data types appropriately\n            if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n              return `${facetName} eq '${value}'`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting based on the selected option\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'ItemNum asc':\n          searchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'ItemNum desc':\n          searchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'ScheduleFee asc':\n          searchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'ScheduleFee desc':\n          searchRequest.orderby = 'ScheduleFee desc';\n          break;\n        case 'ItemStartDate asc':\n          searchRequest.orderby = 'ItemStartDate asc';\n          break;\n        case 'ItemStartDate desc':\n          searchRequest.orderby = 'ItemStartDate desc';\n          break;\n        default:\n          // If the sortBy value is already in the correct format, use it directly\n          if (sortBy.includes(' asc') || sortBy.includes(' desc')) {\n            searchRequest.orderby = sortBy;\n          }\n          break;\n      }\n    } else if (query && query.trim() !== '') {\n      // For non-empty queries, sort by search score by default\n      searchRequest.orderby = 'search.score() desc';\n    } else {\n      // For empty queries, sort by ItemNum by default\n      searchRequest.orderby = 'ItemNum asc';\n    }\n    console.log('Search request:', JSON.stringify(searchRequest, null, 2));\n\n    // Make the search request\n    const response = await fetch(`${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'api-key': SEARCH_API_KEY\n      },\n      body: JSON.stringify(searchRequest)\n    });\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Search API error response:', errorText);\n      try {\n        var _errorData$error;\n        const errorData = JSON.parse(errorText);\n        throw new Error(`Search API error: ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || response.statusText}`);\n      } catch (parseError) {\n        throw new Error(`Search API error: ${response.status} ${response.statusText}`);\n      }\n    }\n    const data = await response.json();\n    console.log('Search API response:', data);\n\n    // Process facets\n    const facets = {};\n    if (data['@search.facets']) {\n      for (const [facetName, facetValues] of Object.entries(data['@search.facets'])) {\n        if (facetName === 'CategoryDescription' || facetName === 'GroupDescription') {\n          facets[facetName] = facetValues.map(facet => {\n            var _selectedFacets$facet;\n            return {\n              value: facet.value,\n              count: facet.count,\n              selected: ((_selectedFacets$facet = selectedFacets[facetName]) === null || _selectedFacets$facet === void 0 ? void 0 : _selectedFacets$facet.includes(facet.value)) || false\n            };\n          });\n        }\n      }\n    }\n\n    // Process results and add highlighted text if available\n    const processedResults = data.value.map(item => {\n      // Debug highlight information\n      console.log(`Item ${item.MBSItemId} highlights:`, item['@search.highlights']);\n\n      // Check if this item has highlights in the response\n      if (item['@search.highlights'] && item['@search.highlights'].Description && item['@search.highlights'].Description.length > 0) {\n        return {\n          ...item,\n          highlightedDescription: item['@search.highlights'].Description[0]\n        };\n      }\n      return item;\n    });\n\n    // Process semantic answers if available\n    let semanticAnswers = null;\n    if (data['@search.answers']) {\n      semanticAnswers = data['@search.answers'].map(answer => ({\n        text: answer.text,\n        highlights: answer.highlights,\n        score: answer.score\n      }));\n      console.log('Semantic answers:', semanticAnswers);\n    }\n\n    // Process semantic captions if available\n    if (data['@search.captions']) {\n      processedResults.forEach((item, index) => {\n        if (data['@search.captions'][index]) {\n          item.semanticCaption = data['@search.captions'][index].text;\n        }\n      });\n    }\n    return {\n      results: processedResults || [],\n      facets: facets,\n      count: data['@odata.count'] || 0,\n      semanticAnswers: semanticAnswers\n    };\n  } catch (error) {\n    console.error('Error searching MBS items:', error);\n    throw error;\n  }\n};\n\n/**\n * Fetch all search results for export\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type (simple or semantic)\n * @param {number} fuzzyLevel - Fuzzy search level (0-3, where 0 means no fuzzy search)\n * @returns {Promise<Array>} - All search results\n */\nexport const fetchAllResultsForExport = async (query, selectedFacets = {}, sortBy = 'relevance', queryType = 'simple', fuzzyLevel = 0) => {\n  try {\n    console.log('Fetching all results for export with query:', query);\n\n    // First, get the total count of results\n    const countRequest = {\n      search: query || '*',\n      queryType: queryType === 'semantic' ? 'semantic' : 'simple',\n      searchFields: 'Description',\n      select: 'MBSItemId',\n      // Just need one field for count\n      count: true,\n      skip: 0,\n      top: 1 // Just need one result to get the count\n    };\n\n    // Add fuzzy search if enabled\n    if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n      countRequest.searchMode = 'all';\n      countRequest.queryType = 'full';\n      if (query && query.trim() !== '') {\n        const words = query.trim().split(/\\s+/);\n        const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n        countRequest.search = fuzzyQuery;\n      }\n    }\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n              return `${facetName} eq '${value}'`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      if (filterExpressions.length > 0) {\n        countRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Get the count\n    const countResponse = await fetch(`${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'api-key': SEARCH_API_KEY\n      },\n      body: JSON.stringify(countRequest)\n    });\n    if (!countResponse.ok) {\n      throw new Error(`Count API error: ${countResponse.status} ${countResponse.statusText}`);\n    }\n    const countData = await countResponse.json();\n    const totalCount = countData['@odata.count'] || 0;\n    console.log(`Total results to export: ${totalCount}`);\n\n    // Emit progress event\n    window.dispatchEvent(new CustomEvent('export-progress', {\n      detail: {\n        progress: 10\n      }\n    }));\n\n    // If no results, return empty array\n    if (totalCount === 0) {\n      return [];\n    }\n\n    // Now fetch all results in batches\n    const batchSize = 1000; // Azure Search max batch size\n    const batches = Math.ceil(totalCount / batchSize);\n    let allResults = [];\n\n    // Build the base search request\n    const baseSearchRequest = {\n      search: query || '*',\n      queryType: queryType === 'semantic' ? 'semantic' : 'simple',\n      searchFields: 'Description',\n      select: ['MBSItemId', 'ItemNum', 'ItemNumAlias', 'Description', 'HumanReadableDescription', 'Category', 'CategoryDescription', 'Group', 'GroupDescription', 'ItemType', 'ItemStartDate', 'ItemEndDate', 'ScheduleFee', 'NewItem', 'FeeType'].join(','),\n      count: false,\n      top: batchSize\n    };\n\n    // Add fuzzy search if enabled\n    if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n      baseSearchRequest.searchMode = 'all';\n      baseSearchRequest.queryType = 'full';\n      if (query && query.trim() !== '') {\n        const words = query.trim().split(/\\s+/);\n        const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n        baseSearchRequest.search = fuzzyQuery;\n      }\n    }\n\n    // Add semantic search configuration if queryType is semantic\n    if (queryType === 'semantic') {\n      baseSearchRequest.queryLanguage = 'en-us';\n      baseSearchRequest.semanticConfiguration = 'default';\n    }\n\n    // Add filters based on selected facets\n    if (countRequest.filter) {\n      baseSearchRequest.filter = countRequest.filter;\n    }\n\n    // Add sorting based on the selected option\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'ItemNum asc':\n          baseSearchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'ItemNum desc':\n          baseSearchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'ScheduleFee asc':\n          baseSearchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'ScheduleFee desc':\n          baseSearchRequest.orderby = 'ScheduleFee desc';\n          break;\n        case 'ItemStartDate asc':\n          baseSearchRequest.orderby = 'ItemStartDate asc';\n          break;\n        case 'ItemStartDate desc':\n          baseSearchRequest.orderby = 'ItemStartDate desc';\n          break;\n        default:\n          if (sortBy.includes(' asc') || sortBy.includes(' desc')) {\n            baseSearchRequest.orderby = sortBy;\n          }\n          break;\n      }\n    } else if (query && query.trim() !== '') {\n      baseSearchRequest.orderby = 'search.score() desc';\n    } else {\n      baseSearchRequest.orderby = 'ItemNum asc';\n    }\n\n    // Fetch all batches\n    for (let i = 0; i < batches; i++) {\n      const skip = i * batchSize;\n      const searchRequest = {\n        ...baseSearchRequest,\n        skip: skip\n      };\n      console.log(`Fetching batch ${i + 1}/${batches} (skip: ${skip}, top: ${batchSize})`);\n\n      // Calculate and emit progress (10-70% range for fetching)\n      const progressPercent = 10 + Math.round(i / batches * 60);\n      window.dispatchEvent(new CustomEvent('export-progress', {\n        detail: {\n          progress: progressPercent\n        }\n      }));\n      const response = await fetch(`${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': SEARCH_API_KEY\n        },\n        body: JSON.stringify(searchRequest)\n      });\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(`Export API error response (batch ${i + 1}):`, errorText);\n        try {\n          var _errorData$error2;\n          const errorData = JSON.parse(errorText);\n          throw new Error(`Export API error: ${((_errorData$error2 = errorData.error) === null || _errorData$error2 === void 0 ? void 0 : _errorData$error2.message) || response.statusText}`);\n        } catch (parseError) {\n          throw new Error(`Export API error: ${response.status} ${response.statusText}`);\n        }\n      }\n      const data = await response.json();\n      console.log(`Batch ${i + 1} results: ${data.value.length}`);\n\n      // Add results from this batch\n      allResults = [...allResults, ...data.value];\n    }\n    console.log(`Total results fetched for export: ${allResults.length}`);\n    return allResults;\n  } catch (error) {\n    console.error('Error fetching all results for export:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["SEARCH_API_ENDPOINT","process","env","REACT_APP_AZURE_SEARCH_SERVICE","SEARCH_API_KEY","REACT_APP_AZURE_SEARCH_API_KEY","SEARCH_INDEX_NAME","REACT_APP_AZURE_SEARCH_INDEX_NAME","SEARCH_API_VERSION","searchItems","query","selectedFacets","page","sortBy","queryType","fuzzyLevel","console","log","searchRequest","search","searchFields","select","join","count","facets","skip","top","highlight","highlightPreTag","highlightPostTag","searchMode","trim","words","split","fuzzyQuery","map","word","queryLanguage","semanticConfiguration","queryAnswer","captions","Object","keys","length","filterExpressions","facetName","facetValues","entries","facetFilters","value","replace","push","filter","orderby","includes","JSON","stringify","response","fetch","method","headers","body","ok","errorText","text","error","_errorData$error","errorData","parse","Error","message","statusText","parseError","status","data","json","facet","_selectedFacets$facet","selected","processedResults","item","MBSItemId","Description","highlightedDescription","semanticAnswers","answer","highlights","score","forEach","index","semanticCaption","results","fetchAllResultsForExport","countRequest","countResponse","countData","totalCount","window","dispatchEvent","CustomEvent","detail","progress","batchSize","batches","Math","ceil","allResults","baseSearchRequest","i","progressPercent","round","_errorData$error2"],"sources":["C:/Projects/MBSSearchReact/mbs-search-app/src/services/searchService.js"],"sourcesContent":["// Azure Cognitive Search service configuration\nconst SEARCH_API_ENDPOINT = process.env.REACT_APP_AZURE_SEARCH_SERVICE || 'https://testopenaiservice102.search.windows.net';\nconst SEARCH_API_KEY = process.env.REACT_APP_AZURE_SEARCH_API_KEY || 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2'; \nconst SEARCH_INDEX_NAME = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME || 'azuresql-index-v2';\nconst SEARCH_API_VERSION = '2021-04-30-Preview'; // Using preview version for semantic search\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type (simple or semantic)\n * @param {number} fuzzyLevel - Fuzzy search level (0-3, where 0 means no fuzzy search)\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance', queryType = 'simple', fuzzyLevel = 0) => {\n  try {\n    console.log('Searching with query:', query);\n    console.log('API Endpoint:', SEARCH_API_ENDPOINT);\n    console.log('Index Name:', SEARCH_INDEX_NAME);\n    console.log('Query Type:', queryType);\n    console.log('Fuzzy Level:', fuzzyLevel);\n    \n    // Build the search request\n    const searchRequest = {\n      search: query || '*', // Use '*' for empty queries to return all results\n      queryType: queryType === 'semantic' ? 'semantic' : 'simple', // Use semantic or simple query type\n      searchFields: 'Description', // Search in Description field\n      select: [\n        'MBSItemId', 'ItemNum', 'ItemNumAlias', 'Description', 'HumanReadableDescription',\n        'Category', 'CategoryDescription', 'Group', 'GroupDescription', 'ItemType',\n        'ItemStartDate', 'ItemEndDate', 'ScheduleFee', 'NewItem', 'FeeType'\n      ].join(','),\n      count: true,\n      facets: [\n        'CategoryDescription',\n        'GroupDescription'\n      ],\n      skip: (page - 1) * 10,\n      top: 10,\n      highlight: 'Description', // Add highlighting for Description field\n      highlightPreTag: '<mark>', // HTML tag to wrap highlighted terms (start)\n      highlightPostTag: '</mark>' // HTML tag to wrap highlighted terms (end)\n    };\n\n    // Add fuzzy search if enabled\n    if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n      searchRequest.searchMode = 'all'; // Match all terms (AND operator)\n      searchRequest.queryType = 'full'; // Use full Lucene query syntax for fuzzy search\n      \n      // Reformat query for fuzzy search if it's not empty\n      if (query && query.trim() !== '') {\n        // Split the query into words and add fuzzy operator to each\n        const words = query.trim().split(/\\s+/);\n        const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n        searchRequest.search = fuzzyQuery;\n        console.log('Fuzzy query:', fuzzyQuery);\n      }\n    }\n\n    // Add semantic search configuration if queryType is semantic\n    if (queryType === 'semantic') {\n      searchRequest.queryLanguage = 'en-us';\n      searchRequest.semanticConfiguration = 'default';\n      searchRequest.queryAnswer = 'extractive|count-3';\n      searchRequest.captions = 'extractive|highlight-false';\n    }\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      \n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            // Handle different data types appropriately\n            if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n              return `${facetName} eq '${value}'`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          \n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      \n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting based on the selected option\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'ItemNum asc':\n          searchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'ItemNum desc':\n          searchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'ScheduleFee asc':\n          searchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'ScheduleFee desc':\n          searchRequest.orderby = 'ScheduleFee desc';\n          break;\n        case 'ItemStartDate asc':\n          searchRequest.orderby = 'ItemStartDate asc';\n          break;\n        case 'ItemStartDate desc':\n          searchRequest.orderby = 'ItemStartDate desc';\n          break;\n        default:\n          // If the sortBy value is already in the correct format, use it directly\n          if (sortBy.includes(' asc') || sortBy.includes(' desc')) {\n            searchRequest.orderby = sortBy;\n          }\n          break;\n      }\n    } else if (query && query.trim() !== '') {\n      // For non-empty queries, sort by search score by default\n      searchRequest.orderby = 'search.score() desc';\n    } else {\n      // For empty queries, sort by ItemNum by default\n      searchRequest.orderby = 'ItemNum asc';\n    }\n\n    console.log('Search request:', JSON.stringify(searchRequest, null, 2));\n\n    // Make the search request\n    const response = await fetch(\n      `${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': SEARCH_API_KEY\n        },\n        body: JSON.stringify(searchRequest)\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Search API error response:', errorText);\n      try {\n        const errorData = JSON.parse(errorText);\n        throw new Error(`Search API error: ${errorData.error?.message || response.statusText}`);\n      } catch (parseError) {\n        throw new Error(`Search API error: ${response.status} ${response.statusText}`);\n      }\n    }\n\n    const data = await response.json();\n    console.log('Search API response:', data);\n\n    // Process facets\n    const facets = {};\n    if (data['@search.facets']) {\n      for (const [facetName, facetValues] of Object.entries(data['@search.facets'])) {\n        if (facetName === 'CategoryDescription' || facetName === 'GroupDescription') {\n          facets[facetName] = facetValues.map(facet => ({\n            value: facet.value,\n            count: facet.count,\n            selected: selectedFacets[facetName]?.includes(facet.value) || false\n          }));\n        }\n      }\n    }\n\n    // Process results and add highlighted text if available\n    const processedResults = data.value.map(item => {\n      // Debug highlight information\n      console.log(`Item ${item.MBSItemId} highlights:`, item['@search.highlights']);\n      \n      // Check if this item has highlights in the response\n      if (item['@search.highlights'] && item['@search.highlights'].Description && item['@search.highlights'].Description.length > 0) {\n        return {\n          ...item,\n          highlightedDescription: item['@search.highlights'].Description[0]\n        };\n      }\n      return item;\n    });\n\n    // Process semantic answers if available\n    let semanticAnswers = null;\n    if (data['@search.answers']) {\n      semanticAnswers = data['@search.answers'].map(answer => ({\n        text: answer.text,\n        highlights: answer.highlights,\n        score: answer.score\n      }));\n      console.log('Semantic answers:', semanticAnswers);\n    }\n\n    // Process semantic captions if available\n    if (data['@search.captions']) {\n      processedResults.forEach((item, index) => {\n        if (data['@search.captions'][index]) {\n          item.semanticCaption = data['@search.captions'][index].text;\n        }\n      });\n    }\n\n    return {\n      results: processedResults || [],\n      facets: facets,\n      count: data['@odata.count'] || 0,\n      semanticAnswers: semanticAnswers\n    };\n  } catch (error) {\n    console.error('Error searching MBS items:', error);\n    throw error;\n  }\n};\n\n/**\n * Fetch all search results for export\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {string} sortBy - Sort option\n * @param {string} queryType - Query type (simple or semantic)\n * @param {number} fuzzyLevel - Fuzzy search level (0-3, where 0 means no fuzzy search)\n * @returns {Promise<Array>} - All search results\n */\nexport const fetchAllResultsForExport = async (query, selectedFacets = {}, sortBy = 'relevance', queryType = 'simple', fuzzyLevel = 0) => {\n  try {\n    console.log('Fetching all results for export with query:', query);\n    \n    // First, get the total count of results\n    const countRequest = {\n      search: query || '*',\n      queryType: queryType === 'semantic' ? 'semantic' : 'simple',\n      searchFields: 'Description',\n      select: 'MBSItemId', // Just need one field for count\n      count: true,\n      skip: 0,\n      top: 1, // Just need one result to get the count\n    };\n    \n    // Add fuzzy search if enabled\n    if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n      countRequest.searchMode = 'all';\n      countRequest.queryType = 'full';\n      \n      if (query && query.trim() !== '') {\n        const words = query.trim().split(/\\s+/);\n        const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n        countRequest.search = fuzzyQuery;\n      }\n    }\n    \n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      \n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n              return `${facetName} eq '${value}'`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          \n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      \n      if (filterExpressions.length > 0) {\n        countRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n    \n    // Get the count\n    const countResponse = await fetch(\n      `${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': SEARCH_API_KEY\n        },\n        body: JSON.stringify(countRequest)\n      }\n    );\n    \n    if (!countResponse.ok) {\n      throw new Error(`Count API error: ${countResponse.status} ${countResponse.statusText}`);\n    }\n    \n    const countData = await countResponse.json();\n    const totalCount = countData['@odata.count'] || 0;\n    console.log(`Total results to export: ${totalCount}`);\n    \n    // Emit progress event\n    window.dispatchEvent(new CustomEvent('export-progress', { \n      detail: { progress: 10 } \n    }));\n    \n    // If no results, return empty array\n    if (totalCount === 0) {\n      return [];\n    }\n    \n    // Now fetch all results in batches\n    const batchSize = 1000; // Azure Search max batch size\n    const batches = Math.ceil(totalCount / batchSize);\n    let allResults = [];\n    \n    // Build the base search request\n    const baseSearchRequest = {\n      search: query || '*',\n      queryType: queryType === 'semantic' ? 'semantic' : 'simple',\n      searchFields: 'Description',\n      select: [\n        'MBSItemId', 'ItemNum', 'ItemNumAlias', 'Description', 'HumanReadableDescription',\n        'Category', 'CategoryDescription', 'Group', 'GroupDescription', 'ItemType',\n        'ItemStartDate', 'ItemEndDate', 'ScheduleFee', 'NewItem', 'FeeType'\n      ].join(','),\n      count: false,\n      top: batchSize,\n    };\n    \n    // Add fuzzy search if enabled\n    if (fuzzyLevel > 0 && fuzzyLevel <= 3) {\n      baseSearchRequest.searchMode = 'all';\n      baseSearchRequest.queryType = 'full';\n      \n      if (query && query.trim() !== '') {\n        const words = query.trim().split(/\\s+/);\n        const fuzzyQuery = words.map(word => `${word}~${fuzzyLevel}`).join(' ');\n        baseSearchRequest.search = fuzzyQuery;\n      }\n    }\n    \n    // Add semantic search configuration if queryType is semantic\n    if (queryType === 'semantic') {\n      baseSearchRequest.queryLanguage = 'en-us';\n      baseSearchRequest.semanticConfiguration = 'default';\n    }\n    \n    // Add filters based on selected facets\n    if (countRequest.filter) {\n      baseSearchRequest.filter = countRequest.filter;\n    }\n    \n    // Add sorting based on the selected option\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'ItemNum asc':\n          baseSearchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'ItemNum desc':\n          baseSearchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'ScheduleFee asc':\n          baseSearchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'ScheduleFee desc':\n          baseSearchRequest.orderby = 'ScheduleFee desc';\n          break;\n        case 'ItemStartDate asc':\n          baseSearchRequest.orderby = 'ItemStartDate asc';\n          break;\n        case 'ItemStartDate desc':\n          baseSearchRequest.orderby = 'ItemStartDate desc';\n          break;\n        default:\n          if (sortBy.includes(' asc') || sortBy.includes(' desc')) {\n            baseSearchRequest.orderby = sortBy;\n          }\n          break;\n      }\n    } else if (query && query.trim() !== '') {\n      baseSearchRequest.orderby = 'search.score() desc';\n    } else {\n      baseSearchRequest.orderby = 'ItemNum asc';\n    }\n    \n    // Fetch all batches\n    for (let i = 0; i < batches; i++) {\n      const skip = i * batchSize;\n      const searchRequest = {\n        ...baseSearchRequest,\n        skip: skip\n      };\n      \n      console.log(`Fetching batch ${i+1}/${batches} (skip: ${skip}, top: ${batchSize})`);\n      \n      // Calculate and emit progress (10-70% range for fetching)\n      const progressPercent = 10 + Math.round((i / batches) * 60);\n      window.dispatchEvent(new CustomEvent('export-progress', { \n        detail: { progress: progressPercent } \n      }));\n      \n      const response = await fetch(\n        `${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'api-key': SEARCH_API_KEY\n          },\n          body: JSON.stringify(searchRequest)\n        }\n      );\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(`Export API error response (batch ${i+1}):`, errorText);\n        try {\n          const errorData = JSON.parse(errorText);\n          throw new Error(`Export API error: ${errorData.error?.message || response.statusText}`);\n        } catch (parseError) {\n          throw new Error(`Export API error: ${response.status} ${response.statusText}`);\n        }\n      }\n      \n      const data = await response.json();\n      console.log(`Batch ${i+1} results: ${data.value.length}`);\n      \n      // Add results from this batch\n      allResults = [...allResults, ...data.value];\n    }\n    \n    console.log(`Total results fetched for export: ${allResults.length}`);\n    return allResults;\n  } catch (error) {\n    console.error('Error fetching all results for export:', error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}