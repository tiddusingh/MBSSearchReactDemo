{"ast":null,"code":"// Azure Cognitive Search service configuration\nconst SEARCH_API_ENDPOINT = process.env.REACT_APP_AZURE_SEARCH_SERVICE || 'https://testopenaiservice102.search.windows.net';\nconst SEARCH_API_KEY = process.env.REACT_APP_AZURE_SEARCH_API_KEY || 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2';\nconst SEARCH_INDEX_NAME = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME || 'azuresql-index-v2';\nconst SEARCH_API_VERSION = '2021-04-30-Preview'; // Using preview version for semantic search\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance') => {\n  try {\n    console.log('Searching with query:', query);\n    console.log('API Endpoint:', SEARCH_API_ENDPOINT);\n    console.log('Index Name:', SEARCH_INDEX_NAME);\n\n    // Build the search request\n    const searchRequest = {\n      search: query || '*',\n      // Use '*' for empty queries to return all results\n      queryType: 'simple',\n      // Using simple query type for compatibility\n      searchFields: 'Description',\n      // Search in Description field\n      select: ['MBSItemId', 'ItemNum', 'ItemNumAlias', 'Description', 'HumanReadableDescription', 'Category', 'CategoryDescription', 'Group', 'GroupDescription', 'ItemType', 'ItemStartDate', 'ItemEndDate', 'ScheduleFee', 'NewItem', 'FeeType'].join(','),\n      count: true,\n      facets: ['CategoryDescription', 'GroupDescription'],\n      skip: (page - 1) * 10,\n      top: 10,\n      highlight: 'Description',\n      // Add highlighting for Description field\n      highlightPreTag: '<mark>',\n      // HTML tag to wrap highlighted terms (start)\n      highlightPostTag: '</mark>' // HTML tag to wrap highlighted terms (end)\n    };\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            // Handle different data types appropriately\n            if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n              return `${facetName} eq '${value}'`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting based on the selected option\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'item_num_asc':\n          searchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'item_num_desc':\n          searchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'fee_asc':\n          searchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'fee_desc':\n          searchRequest.orderby = 'ScheduleFee desc';\n          break;\n        default:\n          // Default to relevance sorting\n          break;\n      }\n    } else if (query && query.trim() !== '') {\n      // For non-empty queries, sort by search score by default\n      searchRequest.orderby = 'search.score() desc';\n    } else {\n      // For empty queries, sort by ItemNum by default\n      searchRequest.orderby = 'ItemNum asc';\n    }\n    console.log('Search request:', JSON.stringify(searchRequest, null, 2));\n\n    // Make the search request\n    const response = await fetch(`${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'api-key': SEARCH_API_KEY\n      },\n      body: JSON.stringify(searchRequest)\n    });\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Search API error response:', errorText);\n      try {\n        var _errorData$error;\n        const errorData = JSON.parse(errorText);\n        throw new Error(`Search API error: ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || response.statusText}`);\n      } catch (parseError) {\n        throw new Error(`Search API error: ${response.status} ${response.statusText}`);\n      }\n    }\n    const data = await response.json();\n    console.log('Search API response:', data);\n\n    // Process facets\n    const facets = {};\n    if (data['@search.facets']) {\n      for (const [facetName, facetValues] of Object.entries(data['@search.facets'])) {\n        if (facetName === 'CategoryDescription' || facetName === 'GroupDescription') {\n          facets[facetName] = facetValues.map(facet => {\n            var _selectedFacets$facet;\n            return {\n              value: facet.value,\n              count: facet.count,\n              selected: ((_selectedFacets$facet = selectedFacets[facetName]) === null || _selectedFacets$facet === void 0 ? void 0 : _selectedFacets$facet.includes(facet.value)) || false\n            };\n          });\n        }\n      }\n    }\n\n    // Process results and add highlighted text if available\n    const processedResults = data.value.map(item => {\n      // Debug highlight information\n      console.log(`Item ${item.MBSItemId} highlights:`, item['@search.highlights']);\n\n      // Check if this item has highlights in the response\n      if (item['@search.highlights'] && item['@search.highlights'].Description && item['@search.highlights'].Description.length > 0) {\n        return {\n          ...item,\n          highlightedDescription: item['@search.highlights'].Description[0]\n        };\n      }\n      return item;\n    });\n    return {\n      results: processedResults || [],\n      facets: facets,\n      count: data['@odata.count'] || 0\n    };\n  } catch (error) {\n    console.error('Error searching MBS items:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["SEARCH_API_ENDPOINT","process","env","REACT_APP_AZURE_SEARCH_SERVICE","SEARCH_API_KEY","REACT_APP_AZURE_SEARCH_API_KEY","SEARCH_INDEX_NAME","REACT_APP_AZURE_SEARCH_INDEX_NAME","SEARCH_API_VERSION","searchItems","query","selectedFacets","page","sortBy","console","log","searchRequest","search","queryType","searchFields","select","join","count","facets","skip","top","highlight","highlightPreTag","highlightPostTag","Object","keys","length","filterExpressions","facetName","facetValues","entries","facetFilters","map","value","replace","push","filter","orderby","trim","JSON","stringify","response","fetch","method","headers","body","ok","errorText","text","error","_errorData$error","errorData","parse","Error","message","statusText","parseError","status","data","json","facet","_selectedFacets$facet","selected","includes","processedResults","item","MBSItemId","Description","highlightedDescription","results"],"sources":["C:/Projects/MBSSearchReact/mbs-search-app/src/services/searchService.js"],"sourcesContent":["// Azure Cognitive Search service configuration\nconst SEARCH_API_ENDPOINT = process.env.REACT_APP_AZURE_SEARCH_SERVICE || 'https://testopenaiservice102.search.windows.net';\nconst SEARCH_API_KEY = process.env.REACT_APP_AZURE_SEARCH_API_KEY || 'cEbz7StL7nXVJ2wx6VNO9fXzw1m9hbhtdgTwkBFY90AzSeAQGwJ2'; \nconst SEARCH_INDEX_NAME = process.env.REACT_APP_AZURE_SEARCH_INDEX_NAME || 'azuresql-index-v2';\nconst SEARCH_API_VERSION = '2021-04-30-Preview'; // Using preview version for semantic search\n\n/**\n * Search for MBS items using Azure Cognitive Search\n * @param {string} query - The search query\n * @param {Object} selectedFacets - Selected facet filters\n * @param {number} page - Current page number\n * @param {string} sortBy - Sort option\n * @returns {Promise<Object>} - Search results, facets, and count\n */\nexport const searchItems = async (query, selectedFacets = {}, page = 1, sortBy = 'relevance') => {\n  try {\n    console.log('Searching with query:', query);\n    console.log('API Endpoint:', SEARCH_API_ENDPOINT);\n    console.log('Index Name:', SEARCH_INDEX_NAME);\n    \n    // Build the search request\n    const searchRequest = {\n      search: query || '*', // Use '*' for empty queries to return all results\n      queryType: 'simple', // Using simple query type for compatibility\n      searchFields: 'Description', // Search in Description field\n      select: [\n        'MBSItemId', 'ItemNum', 'ItemNumAlias', 'Description', 'HumanReadableDescription',\n        'Category', 'CategoryDescription', 'Group', 'GroupDescription', 'ItemType',\n        'ItemStartDate', 'ItemEndDate', 'ScheduleFee', 'NewItem', 'FeeType'\n      ].join(','),\n      count: true,\n      facets: [\n        'CategoryDescription',\n        'GroupDescription'\n      ],\n      skip: (page - 1) * 10,\n      top: 10,\n      highlight: 'Description', // Add highlighting for Description field\n      highlightPreTag: '<mark>', // HTML tag to wrap highlighted terms (start)\n      highlightPostTag: '</mark>' // HTML tag to wrap highlighted terms (end)\n    };\n\n    // Add filters based on selected facets\n    if (Object.keys(selectedFacets).length > 0) {\n      const filterExpressions = [];\n      \n      for (const [facetName, facetValues] of Object.entries(selectedFacets)) {\n        if (facetValues.length > 0) {\n          const facetFilters = facetValues.map(value => {\n            // Handle different data types appropriately\n            if (facetName === 'NewItem' || facetName === 'FeeChange' || facetName === 'ItemChange') {\n              return `${facetName} eq '${value}'`;\n            } else {\n              return `${facetName} eq '${value.replace(/'/g, \"''\")}'`;\n            }\n          });\n          \n          filterExpressions.push(`(${facetFilters.join(' or ')})`);\n        }\n      }\n      \n      if (filterExpressions.length > 0) {\n        searchRequest.filter = filterExpressions.join(' and ');\n      }\n    }\n\n    // Add sorting based on the selected option\n    if (sortBy !== 'relevance') {\n      switch (sortBy) {\n        case 'item_num_asc':\n          searchRequest.orderby = 'ItemNum asc';\n          break;\n        case 'item_num_desc':\n          searchRequest.orderby = 'ItemNum desc';\n          break;\n        case 'fee_asc':\n          searchRequest.orderby = 'ScheduleFee asc';\n          break;\n        case 'fee_desc':\n          searchRequest.orderby = 'ScheduleFee desc';\n          break;\n        default:\n          // Default to relevance sorting\n          break;\n      }\n    } else if (query && query.trim() !== '') {\n      // For non-empty queries, sort by search score by default\n      searchRequest.orderby = 'search.score() desc';\n    } else {\n      // For empty queries, sort by ItemNum by default\n      searchRequest.orderby = 'ItemNum asc';\n    }\n\n    console.log('Search request:', JSON.stringify(searchRequest, null, 2));\n\n    // Make the search request\n    const response = await fetch(\n      `${SEARCH_API_ENDPOINT}/indexes/${SEARCH_INDEX_NAME}/docs/search?api-version=${SEARCH_API_VERSION}`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'api-key': SEARCH_API_KEY\n        },\n        body: JSON.stringify(searchRequest)\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Search API error response:', errorText);\n      try {\n        const errorData = JSON.parse(errorText);\n        throw new Error(`Search API error: ${errorData.error?.message || response.statusText}`);\n      } catch (parseError) {\n        throw new Error(`Search API error: ${response.status} ${response.statusText}`);\n      }\n    }\n\n    const data = await response.json();\n    console.log('Search API response:', data);\n\n    // Process facets\n    const facets = {};\n    if (data['@search.facets']) {\n      for (const [facetName, facetValues] of Object.entries(data['@search.facets'])) {\n        if (facetName === 'CategoryDescription' || facetName === 'GroupDescription') {\n          facets[facetName] = facetValues.map(facet => ({\n            value: facet.value,\n            count: facet.count,\n            selected: selectedFacets[facetName]?.includes(facet.value) || false\n          }));\n        }\n      }\n    }\n\n    // Process results and add highlighted text if available\n    const processedResults = data.value.map(item => {\n      // Debug highlight information\n      console.log(`Item ${item.MBSItemId} highlights:`, item['@search.highlights']);\n      \n      // Check if this item has highlights in the response\n      if (item['@search.highlights'] && item['@search.highlights'].Description && item['@search.highlights'].Description.length > 0) {\n        return {\n          ...item,\n          highlightedDescription: item['@search.highlights'].Description[0]\n        };\n      }\n      return item;\n    });\n\n    return {\n      results: processedResults || [],\n      facets: facets,\n      count: data['@odata.count'] || 0\n    };\n  } catch (error) {\n    console.error('Error searching MBS items:', error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}